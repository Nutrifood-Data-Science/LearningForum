[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "",
    "text": "PENDAHULUAN",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "index.html#latar-belakang",
    "href": "index.html#latar-belakang",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "Latar Belakang",
    "text": "Latar Belakang\nOptimisasi menjadi hal yang krusial pada industri manufaktur. Web-based-book ini disusun dalam sudut pandang komputasi dan solver sehingga diharapkan mudah dibaca dan diaplikasikan.\nDisusun oleh Ikang Fadhli.",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "index.html#optimisasi",
    "href": "index.html#optimisasi",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "Optimisasi",
    "text": "Optimisasi\nOptimisasi adalah proses mencari nilai yang optimal dari suatu masalah tertentu. Dalam matematika, optimisasi merujuk pada pencarian nilai minimal atau maksimal dari suatu fungsi real1. Notasi matematikanya dapat ditulis sebagai berikut:\nMisalkan suatu fungsi \\(f\\) yang memetakan dari himpunan \\(A\\) ke bilangan real.\n\\[f: A \\rightarrow \\mathbb{R}\\]\nCari suatu nilai \\(x_0 \\in A\\) sedemikian sehingga:\n\n\\(f(x_0) \\leq f(x), \\forall x \\in A\\) untuk proses minimalisasi.\n\\(f(x_0) \\geq f(x), \\forall x \\in A\\) untuk proses maksimalisasi.\n\nDi dalam kalkulus, kita mengetahui salah satu pendekatan optimisasi di fungsi satu variabel bisa didapatkan dari turunan pertama yang bernilai nol (bisa berupa nilai maksimum atau minimum dari fungsi tersebut).\nNilai \\(x_0 \\in [a,b]\\) disebut minimum atau maksimum di \\(f\\) unimodal saat memenuhi:\n\\[\\frac{d}{dx}f(x_0) = 0\\]\nPierre De Fermat dan Joseph-Louis Lagrange adalah orang-orang yang pertama kali menemukan formula kalkulus untuk mencari nilai optimal. Sementara Isaac Newton dan Johann C. F.Gauss mengusulkan metode iteratif untuk mencari nilai optimal2.\nSalah satu bentuk optimisasi yakni linear programming dimulai oleh Leonid Kantorovich pada 1939. Metode Simplex merupakan salah satu metode penyelesaian optimisasi yang terkenal, pertama kali diperkenalkan pada 1947 oleh George Dantzig sementara di tahun yang sama Theory of Duality diperkenalkan oleh John von Neumann.",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "index.html#riset-operasi",
    "href": "index.html#riset-operasi",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "Riset Operasi",
    "text": "Riset Operasi\nRiset operasi adalah metode antar disiplin ilmu yang digunakan untuk menganalisa masalah nyata dan membuat keputusan untuk kegiatan operasional organisasi atau perusahaan3.\nRiset operasi dimulai pada era Perang Dunia II. Oleh karena peperangan, diperlukan suatu cara yang efektif untuk mengalokasikan resources yang ada sehingga pihak militer Inggris dan Amerika Serikat mengumpulkan ilmuwan-ilmuwan untuk mencari pendekatan yang saintifik dalam memecahkan masalah.\nPada tahun 1940, sekelompok researchers yang dipimpin oleh PMS Blackett dari the University of Manchester melakukan studi tentang Sistem Radar Baru Anti Pesawat Terbang. Kelompok researchers ini sering dijuluki sebagai Kelompok Sirkus Blackett (Blackett’s circus). Julukan ini terjadi karena keberagaman latar belakang disiplin ilmu para researchers tersebut. Mereka terdiri dari disiplin ilmu fisiologi, matematika, astronomi, tentara, surveyor, dan fisika. Pada 1941, kelompok ini terlibat dalam penelitian radar deteksi kapal selam dan pesawat terbang. Blackett kemudian memimpin Naval Operational Research pada Angkatan Laut Kerajaan Inggris Raya. Prinsip-prinsip ilmiah yang digunakan untuk mengambil keputusan dalam suatu operasi dinamai sebagai Riset Operasi.\nSaat Amerika Serikat mulai terlibat pada Perang Dunia II, prinsip riset operasi juga digunakan untuk berbagai operasi militer mereka. Kelompok riset operasi AS bertugas untuk menganalisis serangan udara dan laut tentara NAZI Jerman.\nSelepas Perang Dunia II, penerapan riset operasi dinilai bisa diperluas ke dunia ekonomi, bisnis,engineering, dan sosial. Riset operasi banyak berkaitan dengan berbagai disiplin ilmu seperti matematika, statistika, computer science, dan lainnya. Tidak jarang beberapa pihak menganggap riset operasi itu overlapping dengan disiplin-disiplin ilmu tersebut.\nOleh karena tujuan utama dari aplikasi riset operasi adalah tercapainya hasil yang optimal dari semua kemungkinan perencanaan yang dibuat. Maka pemodelan matematika dan optimisasi bisa dikatakan sebagai disiplin utama dari riset operasi.",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "index.html#riset-operasi-dalam-industri",
    "href": "index.html#riset-operasi-dalam-industri",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "Riset Operasi dalam Industri",
    "text": "Riset Operasi dalam Industri\nRiset operasi merupakan disiplin ilmu yang sangat krusial dalam industri manufaktur karena berperan sebagai tulang punggung efisiensi dan optimalisasi. Dalam lingkungan yang sangat kompetitif, pabrik tidak hanya dituntut untuk memproduksi barang, tetapi harus melakukannya dengan biaya serendah mungkin, waktu secepat mungkin, dan kualitas setinggi mungkin. Riset operasi menyediakan seperangkat alat analitis yang canggih—mulai dari pemodelan matematika, simulasi, hingga algoritma optimisasi—yang mengubah data operasional yang kompleks menjadi wawasan yang dapat ditindaklanjuti. Tanpa pendekatan yang sistematis dan ilmiah ini, keputusan yang diambil seringkali hanya berdasarkan intuisi atau pengalaman semata, yang berisiko menghasilkan pemborosan sumber daya dan peluang yang terlewat.\nManfaat paling mendasar dari penerapan riset operasi adalah optimalisasi rantai pasok dan manajemen inventori. Melalui teknik seperti pemodelan stokastik dan teori antrian, perusahaan dapat menentukan safety stock yang tepat, titik pemesanan ulang (reorder point), dan jumlah pesanan ekonomis (Economic Order Quantity / EOQ). Hal ini secara langsung meminimalkan biaya penyimpanan yang membebani, mengurangi risiko stockout yang menghentikan produksi, dan sekaligus menghindari kelebihan modal yang terikat dalam barang dagangan. Hasilnya adalah rantai pasok yang lebih lincah, responsif, dan hemat biaya.\nPada tingkat proses produksi, riset operasi berperan penting dalam penjadwalan dan perencanaan kapasitas. Teknik seperti linear programming dan constraint programming digunakan untuk membuat jadwal produksi yang optimal, menyeimbangkan beban kerja antar mesin, dan meminimalkan waktu downtime. Algoritma penjadwalan dapat mempertimbangkan berbagai kendala kompleks, seperti waktu setup mesin, ketersediaan tenaga kerja, dan prioritas pesanan, untuk memastikan throughput yang maksimal. Dengan demikian, pabrik dapat meningkatkan utilisasi asetnya, memenuhi tenggat waktu pengiriman dengan lebih konsisten, dan mengurangi bottleneck dalam lini produksi.\nLebih jauh, riset operasi menjadi fondasi untuk peningkatan kualitas dan pemeliharaan yang prediktif. Teknik statistik dan analisis data digunakan untuk mengidentifikasi akar penyebab cacat produksi, mengoptimalkan parameter proses, dan memastikan produk memenuhi spesifikasi kualitas yang ketat. Selain itu, model prediktif dapat menganalisis data sensor dari peralatan untuk memperkirakan kegagalan mesin sebelum terjadi, sehingga memungkinkan pemeliharaan dilakukan tepat waktu dan menghindari kerugian besar akibat kerusakan yang tak terduga. Pendekatan ini bergerak dari paradigma reaktif ke proaktif.\nKesimpulannya, dalam era Industri 4.0 yang didorong oleh data, peran riset operasi dalam manufaktur menjadi semakin sentral dan tak tergantikan. Ia adalah penggerak di balik transformasi digital menuju smart manufacturing dan pabrik cerdas. Dengan menerapkan prinsip-prinsip OR, perusahaan manufaktur tidak hanya dapat mengoptimalkan operasi mereka untuk efisiensi dan profitabilitas jangka pendek, tetapi juga membangun ketahanan, fleksibilitas, dan keunggulan kompetitif yang berkelanjutan untuk menghadapi dinamika pasar di masa depan.",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Pengantar Optimisasi dalam Industri",
    "section": "",
    "text": "https://id.wikipedia.org/wiki/Optimisasi↩︎\nhttps://empowerops.com/en/blogs/2018/12/6/brief-history-of-optimization↩︎\nPengantar Riset Operasi dan Optimisasi, KampusX: PO101↩︎",
    "crumbs": [
      "PENDAHULUAN"
    ]
  },
  {
    "objectID": "pre_1.html",
    "href": "pre_1.html",
    "title": "1  OPTIMISASI",
    "section": "",
    "text": "1.1 Bahasan dalam Optimisasi\nBahasan dalam optimisasi dapat dikategorikan menjadi:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#bahasan-dalam-optimisasi",
    "href": "pre_1.html#bahasan-dalam-optimisasi",
    "title": "1  OPTIMISASI",
    "section": "",
    "text": "Pemodelan masalah nyata menjadi masalah optimisasi.\nPembahasan karakteristik dari masalah optimisasi dan keberadaan solusi dari masalah optimisasi tersebut.\nPengembangan dan penggunaan algoritma serta analisis numerik untuk mencari solusi dari masalah tersebut.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#masalah-optimisasi",
    "href": "pre_1.html#masalah-optimisasi",
    "title": "1  OPTIMISASI",
    "section": "1.2 Masalah Optimisasi",
    "text": "1.2 Masalah Optimisasi\nMasalah optimisasi adalah masalah matematika yang mewakili masalah nyata (real). Dari ekspresi matematika tersebut, ada beberapa hal yang perlu diketahui1, yakni:\n\nVariabel adalah suatu simbol yang memiliki banyak nilai dan nilainya ingin kita ketahui. Setiap nilai yang mungkin dari suatu variabel muncul akibat suatu kondisi tertentu di sistem.\nParameter di suatu model matematika adalah suatu konstanta yang menggambarkan suatu karakteristik dari sistem yang sedang diteliti. Parameter bersifat fixed atau given.\nConstraints (atau kendala) adalah kondisi atau batasan yang harus dipenuhi. Kendala-kendala ini dapat dituliskan menjadi suatu persamaan atau pertaksamaan. Suatu masalah optimisasi dapat memiliki hanya satu kendala atau banyak kendala.\nObjective function adalah satu fungsi (pemetaan dari variabel-varibel keputusan ke suatu nilai di daerah feasible) yang nilainya akan kita minimumkan atau kita maksimumkan.\n\nEkspresi matematika dari model optimisasi adalah sebagai berikut:\n\nCari \\(x\\) yang meminimumkan \\(f(x)\\) dengan kendala \\(g(x) = 0, h(x) \\leq 0\\) dan \\(x \\in D\\).\n\nDari ekspresi tersebut, kita bisa membagi-bagi masalah optimisasi tergantung dari:\n\nTipe variabel yang terlibat.\nJenis fungsi yang ada (baik objective function ataupun constraints).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#jenis-jenis-masalah-optimisasi",
    "href": "pre_1.html#jenis-jenis-masalah-optimisasi",
    "title": "1  OPTIMISASI",
    "section": "1.3 Jenis-Jenis Masalah Optimisasi",
    "text": "1.3 Jenis-Jenis Masalah Optimisasi\nMasalah optimisasi bisa dibagi dua menjadi dua kategori berdasarkan tipe variables yang terlibat2, yakni:\n\n\n\n\n\n\nDiscrete Optimization: merupakan masalah optimisasi di mana variabel yang terkait merupakan variabel diskrit, seperti binary atau integer (bilangan bulat). Namun pada masalah optimisasi berbentuk mixed integer linear programming, dimungkinkan suatu masalah optimisasi memiliki berbagai jeni variabel yang terlibat (integer dan kontinu sekaligus).\nContinuous Optimization: merupakan masalah optimisasi di mana variabel yang terkait merupakan variabel kontinu (bilangan real). Pada masalah optimisasi jenis ini, fungsi-fungsi yang terlibat bisa diferensiabel atau tidak. Konsekuensinya adalah pada metode penyelesaiannya.\n\nSelain itu, kita juga bisa membagi masalah optimisasi berdasarkan kepastian nilai variable dan parameter yang dihadapi sebagai berikut:\n\n\n\n\n\n\nOptimization under uncertainty3; Pada beberapa kasus di dunia real, data dari masalah tidak dapat diketahui secara akurat karena berbagai alasan. Hal ini mungkin terjadi akibat:\n\nKesalahan dalam pengukuran, atau\nData melibatkan sesuatu di masa depan yang belum terjadi atau tidak pasti. Contoh: demand produk, harga barang, dan sebagainya.\n\nDeterministic optimization;\n\nModel deterministik adalah model matematika di mana nilai dari semua parameter dan variabel yang terkandung di dalam model merupakan satu nilai pasti4.\nPendekatan deterministik memanfaatkan sifat analitik masalah untuk menghasilkan barisan titik yang konvergen ke solusi optimal.\nSemua algoritma perhitungan mengikuti pendekatan matematis yang ketat.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#optimisasi-berdasarkan-seberapa-banyak-objectives-nya",
    "href": "pre_1.html#optimisasi-berdasarkan-seberapa-banyak-objectives-nya",
    "title": "1  OPTIMISASI",
    "section": "1.4 Optimisasi Berdasarkan Seberapa Banyak Objectives-nya",
    "text": "1.4 Optimisasi Berdasarkan Seberapa Banyak Objectives-nya\nSuatu permasalahan optimisasi bisa dikategorikan menjadi dua jenis:\n\nSingle objective optimization, adalah proses menemukan solusi terbaik untuk suatu masalah yang hanya memiliki satu tujuan atau kriteria yang ingin dimaksimalkan atau diminimalkan. Ini adalah bentuk optimisasi yang paling fundamental dan banyak digunakan dalam berbagai bidang seperti teknik, ekonomi, ilmu data, dan machine learning.\nMulti objective optimization, adalah proses mencari solusi optimal ketika terdapat beberapa tujuan (objectives) yang saling bertentangan (conflicting) yang harus dioptimalkan secara simultan. Tidak seperti single objective yang memiliki satu solusi optimal, MOO menghasilkan himpunan solusi optimal yang mewakili trade-off antara berbagai tujuan.\n\n\n1.4.1 Representasi Matematis Single Objective\nSecara formal, single objective optimization dapat dinyatakan sebagai:\nMinimisasi: [ \\(\\min_{x \\in S} f(x)\\) ] atau Maksimisasi: [ \\(\\max_{x \\in S} f(x)\\) ].\nDi mana:\n\n\\(f(x)\\) adalah fungsi objektif (objective function) yang ingin kita minimalkan atau maksimalkan.\n\\(x\\) adalah vektor variabel keputusan (decision variables).\n\\(S\\) adalah ruang pencarian atau himpunan solusi layak (feasible region) yang memenuhi semua kendala.\n\n\n\n1.4.2 Representasi Matematis Multi Objective\nMasalah MOO dapat dinyatakan sebagai:\n\\[\\min_{x \\in S} \\mathbf{F}(x) = [f_1(x), f_2(x), ..., f_k(x)]^T\\]\nDi mana:\n\n\\(\\mathbf{F}(x)\\) adalah vektor fungsi objektif (bukan skalar).\n\\(f_i(x)\\) adalah fungsi objektif ke-i (\\(i = 1, 2, ..., k\\)).\n\\(x\\) adalah vektor variabel keputusan.\n\\(S\\) adalah ruang solusi layak yang memenuhi semua kendala.\n\n\n\n1.4.3 Menyelesaikan MOO\nAda beberapa cara menyelesaikan MOO:\nMetode Scalarization (A Priori): Mengkonversi multi-objective menjadi single objective. Caranya:\n\nWeighted Sum Method: ( \\(\\min \\sum w_i f_i(x)\\) ) yakni dengan memberikan bobot untuk masing-masing objective functions sesuai dengan kebutuhan.\nε-Constraint Method: Optimize satu objective function, dan menjadikan objective function yang lain menjadi constraint dengan batas suatu nilai ε.\n\nMetode Evolutionary (A Posteriori): Menghasilkan seluruh Pareto front. Caranya:\n\nNSGA-II (Non-dominated Sorting Genetic Algorithm).\nMOEA/D (Multi-Objective Evolutionary Algorithm based on Decomposition).\nSPEA2 (Strength Pareto Evolutionary Algorithm).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#optimisasi-berdasarkan-bentuk-objectives-function-nya",
    "href": "pre_1.html#optimisasi-berdasarkan-bentuk-objectives-function-nya",
    "title": "1  OPTIMISASI",
    "section": "1.5 Optimisasi Berdasarkan Bentuk Objectives Function-nya",
    "text": "1.5 Optimisasi Berdasarkan Bentuk Objectives Function-nya\nKita bisa membagi optimisasi berdasarkan bentuk objective function-nya, yakni:\n\nLinear optimization adalah metode matematis untuk menemukan nilai maksimum atau minimum dari suatu fungsi tujuan (objective function) linear, dengan mematuhi serangkaian batasan (constraints) yang juga linear.\nNon linear optimization adalah proses menemukan nilai maksimum atau minimum dari suatu fungsi tujuan (objective function) yang non-linear, dengan mematuhi serangkaian batasan (constraints) yang juga bisa non-linear.\n\n\nInti perbedaannya dengan Linear Optimization: Hubungan antara variabel-variabelnya tidak harus lurus. Fungsi tujuan atau batasannya dapat melibatkan kurva, polinomial, eksponensial, interaksi antar variabel, dan bentuk-bentuk kompleks lainnya.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#catatan",
    "href": "pre_1.html#catatan",
    "title": "1  OPTIMISASI",
    "section": "1.6 Catatan",
    "text": "1.6 Catatan\nHampir semua libraries solver yang umum tersedia hanya diperuntukkan untuk menyelesaikan masalah single objective dan linear saja. Oleh karena itu, jika memiliki keterbatasan untuk hanya isa bekerja dengan solver tersebut, maka kita perlu memodifikasi masalah kita agar menjadi bentuk yang kompatibel dengan solver tersebut.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_1.html#footnotes",
    "href": "pre_1.html#footnotes",
    "title": "1  OPTIMISASI",
    "section": "",
    "text": "Pengantar Riset Operasi dan Optimisasi, KampusX: PO101↩︎\nOptimization problem. https://en.wikipedia.org/wiki/Optimization_problem↩︎\nhttps://neos-guide.org/content/optimization-under-uncertainty↩︎\nPengantar Riset Operasi dan Optimisasi, KampusX: PO101↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_2.html",
    "href": "pre_2.html",
    "title": "2  JENIS OPTIMISASI",
    "section": "",
    "text": "2.1 Linear Programming\nLinear programming adalah bentuk metode optimisasi sederhana yang memanfaatkan relasi linear (semua fungsi dan constraints merupakan fungsi linear).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>JENIS OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_2.html#linear-programming",
    "href": "pre_2.html#linear-programming",
    "title": "2  JENIS OPTIMISASI",
    "section": "",
    "text": "2.1.1 Contoh Masalah Linear Programming\nSaya memiliki area parkir seluas 1.960 \\(m^2\\). Luas rata-rata untuk mobil berukuran kecil adalah 4 \\(m^2\\) dan mobil besar adalah 20 \\(m^2\\). Daya tampung maksimum hanya 250 kendaraan, biaya parkir mobil kecil adalah Rp 7.000 per jam dan mobil besar adalah Rp 12.000 per jam. Jika dalam 1 jam area parkir saya terisi penuh dan tidak ada kendaraan yang pergi dan datang, maka berapa pendapatan maksimum yang bisa saya dapatkan dari tempat parkir itu?\nDari kasus di atas kita bisa tuliskan model matematikanya sebagai berikut:\nMisal \\(x_1\\) adalah mobil kecil dan \\(x_2\\) adalah mobil besar.\n\\[max(7000x_1 + 12000x_2)\\]\nDengan constraints:\n\\[4 x_1 + 20 x_2 \\leq 1960\\]\ndan\n\\[x_1 + x_2 \\leq 250\\]\nserta \\(x_1 \\geq 0, x_2 \\geq 0\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>JENIS OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_2.html#integer-programming",
    "href": "pre_2.html#integer-programming",
    "title": "2  JENIS OPTIMISASI",
    "section": "2.2 Integer Programming",
    "text": "2.2 Integer Programming\nInteger programming adalah bentuk metode optimisasi di mana variabel yang terlibat merupakan bilangan bulat (integer). Jika fungsi-fungsi yang terkait merupakan linear, maka disebut dengan integer linear programming.\nSebagai contoh, variabel yang merupakan bilangan bulat adalah banyak orang.\n\n2.2.1 Contoh Integer Programming\n\nJadwal Kebutuhan Tenaga Kesehatan\nSuatu rumah sakit membutuhkan tenaga kesehatan setiap harinya dengan spesifikasi berikut:\n\n\n\nTabel Kebutuhan Nakes Harian\n\n\nhari\nMin Nakes Required\nMax Nakes Required\n\n\n\n\nSenin\n24\n29\n\n\nSelasa\n22\n27\n\n\nRabu\n23\n28\n\n\nKamis\n11\n16\n\n\nJumat\n16\n21\n\n\nSabtu\n20\n25\n\n\nMinggu\n12\n17\n\n\n\n\n\nDi rumah sakit tersebut berlaku kondisi sebagai berikut:\n\nSetiap nakes hanya diperbolehkan bekerja selama 5 hari berturut-turut dan harus libur selama 2 hari berturut-turut.\nTidak ada pemberlakuan shift bagi nakes.\n\nBerapa banyak nakes yang harus dipekerjakan oleh rumah sakit tersebut? Bagaimana konfigurasi penjadwalannya?\nUntuk memudahkan dalam mencari solusi permasalahan di atas, kita bisa membuat tabel ilustrasi berikut:\n\n\n\nKonfigurasi Penjadwalan Nakes\n\n\nhari\nMin Nakes Required\nMax Nakes Required\nx1\nx2\nx3\nx4\nx5\nx6\nx7\n\n\n\n\nSenin\n24\n29\nx\n\n\nx\nx\nx\nx\n\n\nSelasa\n22\n27\nx\nx\n\n\nx\nx\nx\n\n\nRabu\n23\n28\nx\nx\nx\n\n\nx\nx\n\n\nKamis\n11\n16\nx\nx\nx\nx\n\n\nx\n\n\nJumat\n16\n21\nx\nx\nx\nx\nx\n\n\n\n\nSabtu\n20\n25\n\nx\nx\nx\nx\nx\n\n\n\nMinggu\n12\n17\n\n\nx\nx\nx\nx\nx\n\n\n\n\n\nKolom \\(x_i, i =1,2,3,4,5,6,7\\) menandakan kelompok nakes yang perlu dipekerjaan pada hari-hari tertentu. Setiap nilai \\(x_i\\) tersebut merupakan bilangan bulat positif \\(x \\geq 0, x \\in \\mathbb{Z}\\).\nDari ilustrasi di atas, kita bisa membuat model optimisasinya sebagai berikut:\nObjective Function\n\\[\\min{ \\sum_{i=1}^7 x_i}\\]\nConstraints\n\nHari Senin: \\(24 \\leq \\sum x_i \\leq 29, i \\in \\{1,4,5,6,7\\}\\).\nHari Selasa: \\(22 \\leq \\sum x_i \\leq 27, i \\in \\{1,2,5,6,7\\}\\).\nHari Rabu: \\(23 \\leq \\sum x_i \\leq 28, i \\in \\{1,2,3,6,7\\}\\).\nHari Kamis: \\(11 \\leq \\sum x_i \\leq 16, i \\in \\{1,2,3,4,7\\}\\).\nHari Jumat: \\(16 \\leq \\sum x_i \\leq 21, i \\in \\{1,2,3,4,5\\}\\).\nHari Sabtu: \\(20 \\leq \\sum x_i \\leq 25, i \\in \\{2,3,4,5,6\\}\\).\nHari Minggu: \\(12 \\leq \\sum x_i \\leq 17, i \\in \\{3,4,5,6,7\\}\\).\n\nKita juga perlu perhatikan bahwa \\(x_i \\geq 0, i \\in \\{1,2,3,4,5,6,7\\}\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>JENIS OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_2.html#binary-programming",
    "href": "pre_2.html#binary-programming",
    "title": "2  JENIS OPTIMISASI",
    "section": "2.3 Binary Programming",
    "text": "2.3 Binary Programming\nBinary programming adalah bentuk metode optimisasi di mana variabel yang terlibat merupakan bilangan biner (0,1). Biasanya metode ini dipakai dalam masalah penjadwalan yang memerlukan prinsip matching antar kondisi yang ada.\n\n2.3.1 Contoh Binary Programming\n\nJadwal Tatap Muka Terbatas Sekolah\nBeberapa minggu ke belakang, kasus harian Covid semakin menurun. Pemerintah mulai melonggarkan aturan PPKM yang mengakibatkan sekolah-sekolah mulai menggelar pengajaran tatap muka terbatas (PTMT) untuk siswanya secara offline.\nSuatu sekolah memiliki kelas berisi 20 orang siswa. Mereka hendak menggelar PTMT dengana aturan sebagai berikut:\n\nPTMT digelar dari Senin hingga Jumat (5 hari).\nDalam sehari, siswa yang boleh hadir dibatasi 4-8 orang saja.\nDalam seminggu, diharapkan siswa bisa hadir 2-3 kali.\nSiswa yang hadir di selang sehari baru bisa hadir kembali.\n\nDari uraian di atas, kita bisa membuat model optimisasinya sebagai berikut:\nSaya definisikan \\(x_{i,j} \\in (0,1)\\) sebagai bilangan biner di mana \\(i \\in \\{1,2,..,20\\}\\) menandakan siswa dan \\(j \\in \\{1,2,..,5\\}\\) menandakan hari. Berlaku:\n\\[x_{i,j} = \\left\\{\\begin{matrix}\n0, \\text{ siswa i tidak masuk di hari j}\\\\\n1, \\text{ siswa i masuk di hari j}\n\\end{matrix}\\right.\\]\nObjective Function\nTujuan utama kita adalah memaksimalkan siswa yang hadir.\n\\[\\max{\\sum_{j=1}^5 \\sum_{i=1}^{20} x_{i,j} }\\]\nConstraints\nDalam sehari, ada pembatasan jumlah siswa yang hadir.\n\\[4 \\leq \\sum_i x_{i,j} \\leq 8, j \\in \\{1,2,..,5\\}\\]\nDalam seminggu, siswa hadir dalam frekuensi tertentu.\n\\[2 \\leq \\sum_j x_{i,j} \\leq 3, i \\in \\{1,2,..,20\\}\\]\nAda jeda sehari agar siswa bisa masuk kembali.\n\\[x_{i,j} + x_{i,j+1} \\leq 1\\]\nJangan lupa bahwa \\(x_{i,j} \\geq 0\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>JENIS OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_2.html#mixed-integer-linear-programming",
    "href": "pre_2.html#mixed-integer-linear-programming",
    "title": "2  JENIS OPTIMISASI",
    "section": "2.4 Mixed Integer Linear Programming",
    "text": "2.4 Mixed Integer Linear Programming\nPada bagian sebelumnya, kita telah membahas masalah optimisasi dengan variabel berupa diskrit dan kontinu. Permasalahan real yang ada di kehidupan sehari-hari biasanya merupakan memiliki variabel yang mixed antara keduanya. Oleh karena itu, ada metode yang disebut dengan mixed integer linear programming. Pada masalah optimisasi tipe ini, decision variables yang terlibat bisa saja berupa binary, integer, dan continuous sekaligus.\n\n2.4.1 Menyelesaikan MILP\nMILP secara eksak bisa diselesaikan dengan metode simplex dengan dikombinasikan dengan teknik branch and bound. Penjelasan terkait ini akan dibahas pada bab 6.\n\n\n2.4.2 Contoh MILP\n\nPemilihan dan Penentuan Item Produksi\nSuatu pabrik makanan dan minuman berencana untuk membuat tiga produk baru yang bisa diproduksi di dua plants yang berbeda.\n\n\n\nTabel Runtime Item Produk per Plant (harian - dalam jam)\n\n\nProduk\nRuntime Plant 1\nRuntime Plant 2\n\n\n\n\nItem 1\n3\n4\n\n\nItem 2\n4\n6\n\n\nItem 3\n2\n2\n\n\n\n\n\nPlant 1 memiliki maksimum working hours sebesar 30 jam perhari.\nPlant 2 memiliki maksimum working hours sebesar 40 jam perhari.\n\n\n\nTabel Profit dan Potensi Sales Item Produk\n\n\nProduk\nProfit per ton\nSales potential per ton\n\n\n\n\nItem 1\n5\n7\n\n\nItem 2\n7\n5\n\n\nItem 3\n3\n9\n\n\n\n\n\nMasalah timbul saat mereka harus memilih dua dari tiga produk baru tersebut yang harus di produksi. Selain itu, mereka juga harus memilih satu dari dua plants yang memproduksi items tersebut.\nMisalkan saya definisikan:\n\n\\(x_i \\geq 0, i = 1,2,3\\) sebagai berapa ton yang harus diproduksi dari item \\(i\\).\n\\(y_i \\in [0,1], i = 1,2,3\\) sebagai binary.\n\nJika bernilai 0, maka produk \\(i\\) tidak dipilih.\nJika bernilai 1, maka produk \\(i\\) dipilih.\n\n\\(z \\in [0,1]\\) sebagai binary.\n\nJika bernilai 0, maka plant pertama dipilih.\nJika bernilai 1, maka plant kedua dipilih.\n\n\nSaya akan mendefinisikan suatu variabel dummy \\(M = 99999\\) berisi suatu nilai yang besar. Kelak variabel ini akan berguna untuk reinforce model (metode pemberian penalty) agar bisa memilih items dan plants secara bersamaan.\nObjective function dari masalah ini adalah memaksimalkan profit.\n\\[\\max{ \\sum_{i=1}^3 x_i \\times \\text{profit}_i }\\]\nConstraints dari masalah ini adalah:\nTonase produksi tidak boleh melebihi angka sales potential per items.\n\\[x_i \\leq \\text{sales potential}_i, i = 1,2,3\\]\nKita akan memilih dua produk sekaligus menghitung tonase. Jika produk tersebut dipilih, maka akan ada angka tonase produksinya. Sebaliknya, jika produk tersebut tidak dipilih, maka tidak ada angka tonase produksinya.\n\\[x_i - y_i \\times M \\leq 0, i = 1,2,3\\]\n\\[\\sum_{i=1}^3 y_i \\leq 2\\]\nKita akan memilih plant dari waktu produksinya.\n\\[3x_1 + 4x_2 + 2x_3 - M \\times z \\leq 30\\]\n\\[4x_1 + 6x_2 + 2x_3 + M \\times z \\leq 40 + M\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>JENIS OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_3.html",
    "href": "pre_3.html",
    "title": "3  ALGORITMA PENYELESAIAN OPTIMISASI",
    "section": "",
    "text": "3.1 Exact Method\nPada bagian ini kita akan membahas macam-macam algoritma yang digunakan untuk menyelesaikan masalah optimisasi.\nSecara garis besar ada dua kelompok besar algoritma optimisasi, yakni:\nPerbedaan keduanya adalah pada konsep atau pendekatan apa yang digunakan untuk menyelesaikan masalah optimisasi. Kita akan bahas satu-persatu pada bagian selanjutnya.\nDalam beberapa kasus, kita bisa mendapatkan exact method bisa untuk menyelesaikan masalah optimisasi dengan efisien. Namun di kasus lain yang lebih kompleks tidak demikian. Kelemahan utama metode exact adalah pada waktu komputasinya yang relatif lebih lama.\nCiri khas dari exact method adalah metode ini menjamin penyelesaian yang optimal karena menggunakan pendekatan analitis. Salah satu contoh metode eksak adalah Simplex Method.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>ALGORITMA PENYELESAIAN OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_3.html#approximate-method",
    "href": "pre_3.html#approximate-method",
    "title": "3  ALGORITMA PENYELESAIAN OPTIMISASI",
    "section": "3.2 Approximate Method",
    "text": "3.2 Approximate Method\nCiri khas dari approximate method adalah metode ini tidak menjamin penyelesaian yang optimal karena bersifat aproksimasi atau pendekatan atau hampiran. Oleh karena itu kita perlu melakukan definisi di awal seberapa dekat nilai hampiran tersebut bisa kita terima.\nMetode ini bisa dibagi menjadi dua berdasarkan keterkaitannya dengan suatu masalah, yakni:\n\nHeuristic, metode ini bersifat problem dependent. Artinya metode tersebut hanya bisa dipakai untuk jenis permasalahan tertentu.\n\nContoh: metode nearest neighborhood hanya bisa dipakai untuk menyelesaikan masalah dalam lingkup travelling salesperson problem (TSP).\n\nMeta heuristic, metode ini bersifat problem independent. Artinya metode tersebut tidak tergantung dari jenis permasalahan tertentu. Contoh:\n\nGenetic algorithm.\nSimulated annealing.\nSpiral optimization untuk menyelesaikan masalah mixed integer non linear programming.\nArtifical bee colony algorithm.\n\n\nNamun demikian kedua metode ini bisa saling melengkapi dalam prakteknya.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>ALGORITMA PENYELESAIAN OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_4.html",
    "href": "pre_4.html",
    "title": "4  SOLVER UNTUK OPTIMISASI",
    "section": "",
    "text": "4.1 Menggunakan R\nUntuk menyelesaikan masalah optimisasi menggunakan R, ada beberapa cara yang bisa digunakan, yakni:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>*SOLVER* UNTUK OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_4.html#menggunakan-r",
    "href": "pre_4.html#menggunakan-r",
    "title": "4  SOLVER UNTUK OPTIMISASI",
    "section": "",
    "text": "Menggunakan ompr packages.\nMembuat algoritma dynamic spiral.\n\n\n\n\nAlgoritma\nBentuk obj function\nBanyak obj function\n\n\n\n\nompr\nLinear\nSingle obj function\n\n\nDynamic spiral\nLinear dan non linear\nSingle obj function",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>*SOLVER* UNTUK OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_4.html#menggunakan-python",
    "href": "pre_4.html#menggunakan-python",
    "title": "4  SOLVER UNTUK OPTIMISASI",
    "section": "4.2 Menggunakan Python",
    "text": "4.2 Menggunakan Python\nSelain R, kita juga bisa memanfaatkan open source libraries buatan:\n\nMeta seperti Nevergrad1. Digunakan untuk menyelesaikan multi objective optimization.\nGoogle seperti OR Tools2. Digunakan untuk menyelesaikan single objective optimization.\nPyMoo3 yang digunakan untuk menyelesaikan multi objective optimization.\n\n\n\n\nLibraries\nBentuk obj function\nBanyak obj function\n\n\n\n\nor tools\nLinear\nSingle obj function\n\n\nNevergrad\nLinear\nMulti obj function\n\n\nPymoo\nLinear\nMulti obj function",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>*SOLVER* UNTUK OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_4.html#footnotes",
    "href": "pre_4.html#footnotes",
    "title": "4  SOLVER UNTUK OPTIMISASI",
    "section": "",
    "text": "https://facebookresearch.github.io/nevergrad/↩︎\nhttps://developers.google.com/optimization↩︎\nhttps://pymoo.org/↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>*SOLVER* UNTUK OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_5.html",
    "href": "pre_5.html",
    "title": "5  ompr PACKAGES di R",
    "section": "",
    "text": "5.1 ompr Modelling\nAda satu packages lain di R yang bisa digunakan untuk menyelesaikan masalah optimisasi, yakni bernama ompr. Packages ompr dibuat oleh Dirk Schumacher pada 20181.\nSalah satu keuntungan dari library ini adalah pengunaan operator pipe %&gt;% pada perumusan algoritmanya. Sehingga bagi user yang biasa menggunakan prinsip tidyverse akan merasa sangat terbantu.\nFramework untuk menuliskan model optimisasi menggunakan ompr adalah sebagai berikut:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#ompr-modelling",
    "href": "pre_5.html#ompr-modelling",
    "title": "5  ompr PACKAGES di R",
    "section": "",
    "text": "# mulai membangun model\nMIPModel() %&gt;% \n  \n  # menambah variabel\n  add_variable() %&gt;% \n  \n  # set objective\n  set_objective() %&gt;% \n  \n  # menambah constraints\n  add_constraint()\n\nDecision Variable\nharus didefinisikan sejak awal. Ada berapa dan tipenya seperti apa. Kita bisa menggunakan indexed variables untuk menghemat notasi. Berikut adalah contohnya:\nMIPModel() %&gt;% \n\n  # menambah variabel integer\n  add_variable(x, type = \"integer\") %&gt;% \n  \n  # menambah variabel kontinu\n  add_variable(y, type = \"continuous\") %&gt;% \n  \n  # menambah variabel binary integer\n  add_variable(z, type = \"binary\") %&gt;% \n  \n  # menambah variabel dengan lower bound\n  add_variable(x, lb = 10) %&gt;% \n  \n  # menambah variabel dengan upper dan lower bounds\n  add_variable(y, lb = 5, ub = 10) %&gt;% \n  \n  # menambah 10 variabel berindeks\n  add_variable(p[i], i = 1:10)\n\n\nObjective Function dan Constraints\ndalam ompr bisa dituliskan sebagai fungsi matematika biasa. Bahkan kita bisa menuliskan summation ke dalam algoritmanya. Berikut adalah contohnya:\nMisal ada 3 variabel \\(x_1,x_2,x_3\\), dengan objective function \\(\\sum_i x_i\\) dengan constraint \\(\\sum_i x_i \\leq 7\\).\nMIPModel() %&gt;% \n  add_variable(x[i], i = 1:3) %&gt;% \n  set_objective(sum_expr(x[i], i = 1:3)) %&gt;% \n  add_constraint(sum_expr(x[i], i = 1:3) &lt;= 7)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#contoh-penyelesaian-mixed-integer-linear-programming",
    "href": "pre_5.html#contoh-penyelesaian-mixed-integer-linear-programming",
    "title": "5  ompr PACKAGES di R",
    "section": "5.2 Contoh Penyelesaian Mixed Integer Linear Programming",
    "text": "5.2 Contoh Penyelesaian Mixed Integer Linear Programming\n\\[\\text{maximize: } 7x_1 + 3x_2 + x_3\\]\n\\[\\text{subject to: } \\begin{matrix}\n6x_1 + 4x_2  + 5x_3 \\leq 60 \\\\ 8x_1 + x_2 + 2x_3 \\leq 80 \\\\ 9x_1 + x_2 + 7x_3 \\leq 70 \\\\ x_3 \\geq 0 \\\\ x_1,x_2 \\in \\mathbb{Z}_{\\geq 0}\n\\end{matrix}\\]\nMari kita tuliskan dalam ompr framework berikut:\n\nrm(list=ls())\n\n# memanggil libraries\nlibrary(dplyr)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n\n# membuat model\nmilp_new = \n  MIPModel() %&gt;% \n  \n  # membuat 2 variabel integer\n  add_variable(x1,type = \"integer\",lb = 0) %&gt;% \n  add_variable(x2,type = \"integer\",lb = 0) %&gt;% \n  \n  # membuat 1 variabel kontinu\n  add_variable(x3,type = \"continuous\",lb = 0) %&gt;% \n  \n  # set obj function\n  set_objective(7*x1 + 3*x2 + x3,\n                \"max\") %&gt;% \n  \n  # menuliskan semua constraints\n  add_constraint(6*x1 + 4*x2  + 5*x3 &lt;= 60) %&gt;% \n  add_constraint(8*x1 + x2 + 2*x3 &lt;= 80) %&gt;% \n  add_constraint(9*x1 + x2 + 7*x3 &lt;= 70) \n\nmilp_new\n\nMixed integer linear optimization problem\nVariables:\n  Continuous: 1 \n  Integer: 2 \n  Binary: 0 \nModel sense: maximize \nConstraints: 3 \n\n\nMari kita solve modelnya:\n\nresult = solve_model(milp_new, with_ROI(solver = \"glpk\", verbose = TRUE))\n\n&lt;SOLVER MSG&gt;  ----\nGLPK Simplex Optimizer 5.0\n3 rows, 3 columns, 9 non-zeros\n*     0: obj =  -0.000000000e+00 inf =   0.000e+00 (3)\n*     2: obj =   6.333333333e+01 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer 5.0\n3 rows, 3 columns, 9 non-zeros\n2 integer variables, none of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+     2: mip =     not found yet &lt;=              +inf        (1; 0)\n+     4: &gt;&gt;&gt;&gt;&gt;   6.140000000e+01 &lt;=   6.166666667e+01   0.4% (2; 0)\n+     4: mip =   6.140000000e+01 &lt;=     tree is empty   0.0% (0; 3)\nINTEGER OPTIMAL SOLUTION FOUND\n&lt;!SOLVER MSG&gt; ----\n\nresult\n\nStatus: success\nObjective value: 61.4\n\n\nBerikut adalah hasilnya:\n\nresult %&gt;% get_solution(x1)\n\nx1 \n 7 \n\nresult %&gt;% get_solution(x2)\n\nx2 \n 4 \n\nresult %&gt;% get_solution(x3)\n\n x3 \n0.4 \n\n\n\n5.2.1 Conclusion\nSalah satu ciri khas ompr adalah penulisannya yang mirip dengan notasi matematika sehingga saat kita memiliki suatu model dengan banyak variabel, kita tidak perlu menginputnya ke dalam bentuk matriks.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#penyelesaian-masalah-jadwal-kebutuhan-tenaga-kesehatan",
    "href": "pre_5.html#penyelesaian-masalah-jadwal-kebutuhan-tenaga-kesehatan",
    "title": "5  ompr PACKAGES di R",
    "section": "5.3 Penyelesaian Masalah Jadwal Kebutuhan Tenaga Kesehatan",
    "text": "5.3 Penyelesaian Masalah Jadwal Kebutuhan Tenaga Kesehatan\nDengan menggunakan library(ompr)\n\nrm(list=ls())\n\n# memanggil libraries\nlibrary(dplyr)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n\n# membuat model\ninteger_prog = \n  MIPModel() %&gt;% \n  # membuat variabel\n  add_variable(x[i],\n               type = \"integer\",\n               lb = 0,\n               i = 1:7) %&gt;% \n  # set fungsi objective\n  set_objective(sum_expr(x[i],i = 1:7),\"min\") %&gt;% \n  # memasukkan constraints\n  # senin\n  add_constraint(sum_expr(x[i], i = c(1,4,5,6,7)) &gt;= 24) %&gt;% \n  add_constraint(sum_expr(x[i], i = c(1,4,5,6,7)) &lt;= 29) %&gt;% \n  # selasa\n  add_constraint(sum_expr(x[i], i = c(1,2,5,6,7)) &gt;= 22) %&gt;% \n  add_constraint(sum_expr(x[i], i = c(1,2,5,6,7)) &lt;= 27) %&gt;% \n  # rabu\n  add_constraint(sum_expr(x[i], i = c(1,2,3,6,7)) &gt;= 23) %&gt;% \n  add_constraint(sum_expr(x[i], i = c(1,2,3,6,7)) &lt;= 28) %&gt;% \n  # kamis\n  add_constraint(sum_expr(x[i], i = c(1,2,3,4,7)) &gt;= 11) %&gt;% \n  add_constraint(sum_expr(x[i], i = c(1,2,3,4,7)) &lt;= 16) %&gt;% \n  # jumat\n  add_constraint(sum_expr(x[i], i = 1:5) &gt;= 16) %&gt;% \n  add_constraint(sum_expr(x[i], i = 1:5) &lt;= 21) %&gt;% \n  # sabtu\n  add_constraint(sum_expr(x[i], i = 2:6) &gt;= 20) %&gt;% \n  add_constraint(sum_expr(x[i], i = 2:6) &lt;= 25) %&gt;% \n  # minggu\n  add_constraint(sum_expr(x[i], i = 3:7) &gt;= 12) %&gt;% \n  add_constraint(sum_expr(x[i], i = 3:7) &lt;= 17)\n\ninteger_prog\n\nMixed integer linear optimization problem\nVariables:\n  Continuous: 0 \n  Integer: 7 \n  Binary: 0 \nModel sense: minimize \nConstraints: 14 \n\nhasil = integer_prog %&gt;% solve_model(with_ROI(solver = \"glpk\",verbose = T))\n\n&lt;SOLVER MSG&gt;  ----\nGLPK Simplex Optimizer 5.0\n14 rows, 7 columns, 70 non-zeros\n      0: obj =   0.000000000e+00 inf =   1.280e+02 (7)\n      9: obj =   2.766666667e+01 inf =   0.000e+00 (0)\n*    10: obj =   2.766666667e+01 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer 5.0\n14 rows, 7 columns, 70 non-zeros\n7 integer variables, none of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+    10: mip =     not found yet &gt;=              -inf        (1; 0)\n+    12: &gt;&gt;&gt;&gt;&gt;   2.800000000e+01 &gt;=   2.800000000e+01   0.0% (2; 0)\n+    12: mip =   2.800000000e+01 &gt;=     tree is empty   0.0% (0; 3)\nINTEGER OPTIMAL SOLUTION FOUND\n&lt;!SOLVER MSG&gt; ----\n\n# solusi yang dihasilkan\nhasil$solution\n\nx[1] x[2] x[3] x[4] x[5] x[6] x[7] \n   8    3    1    0    4   12    0 \n\n\nKita telah mendapatkan konfigurasi jadwal nakes yang optimal perharinya.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#penyelesaian-masalah-jadwal-tatap-muka-terbatas-sekolah",
    "href": "pre_5.html#penyelesaian-masalah-jadwal-tatap-muka-terbatas-sekolah",
    "title": "5  ompr PACKAGES di R",
    "section": "5.4 Penyelesaian Masalah Jadwal Tatap Muka Terbatas Sekolah",
    "text": "5.4 Penyelesaian Masalah Jadwal Tatap Muka Terbatas Sekolah\nDengan menggunakan library(ompr)\n\nrm(list=ls())\n\nlibrary(dplyr)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n\nbin_prog = \n  MIPModel() %&gt;%\n  # menambah variabel\n  add_variable(x[i,j],\n           i = 1:20,\n           j = 1:5,\n           type = \"binary\",\n           lb = 0) %&gt;%\n  # membuat objective function\n  set_objective(sum_expr(x[i,j],\n             i = 1:20,\n             j = 1:5),\n        \"max\") %&gt;%\n  # menambah constraints\n  # max kapasitas kelas\n  add_constraint(sum_expr(x[i,j],i = 1:20) &gt;= 4,\n         j = 1:5) %&gt;%\n  add_constraint(sum_expr(x[i,j],i = 1:20) &lt;= 8,\n         j = 1:5) %&gt;%\n  # frek kunjungan siswa\n  add_constraint(sum_expr(x[i,j],j = 1:5) &gt;= 2,\n         i = 1:20) %&gt;%\n  add_constraint(sum_expr(x[i,j],j = 1:5) &lt;= 3,\n         i = 1:20) %&gt;%\n  # jeda sehari\n  add_constraint(x[i,j] + x[i,j+1] &lt;= 1,\n         i = 1:20,\n         j = 1:4)\n\nbin_prog \n\nMixed integer linear optimization problem\nVariables:\n  Continuous: 0 \n  Integer: 0 \n  Binary: 100 \nModel sense: maximize \nConstraints: 130 \n\n\nBerikut adalah hasilnya:\n\n\n&lt;SOLVER MSG&gt;  ----\nGLPK Simplex Optimizer 5.0\n130 rows, 100 columns, 560 non-zeros\n      0: obj =  -0.000000000e+00 inf =   6.000e+01 (25)\n     51: obj =   4.000000000e+01 inf =   0.000e+00 (0)\n*    53: obj =   4.000000000e+01 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer 5.0\n130 rows, 100 columns, 560 non-zeros\n100 integer variables, all of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+    53: mip =     not found yet &lt;=              +inf        (1; 0)\n+    53: &gt;&gt;&gt;&gt;&gt;   4.000000000e+01 &lt;=   4.000000000e+01   0.0% (1; 0)\n+    53: mip =   4.000000000e+01 &lt;=     tree is empty   0.0% (0; 1)\nINTEGER OPTIMAL SOLUTION FOUND\n&lt;!SOLVER MSG&gt; ----\n\n\n\nJadwal Kunjungan Siswa\n\n\nhari\npresensi\n\n\n\n\n1\n1,2,3,4,9,10,11,12\n\n\n2\n5,6,7,8,13,14,15,16\n\n\n3\n1,2,3,4,17,18,19,20\n\n\n4\n5,6,7,8,13,14,15,16\n\n\n5\n9,10,11,12,17,18,19,20\n\n\n\n\n\n\nRekap Presensi Siswa\n\n\nsiswa\njumlah kehadiran\n\n\n\n\n1\n2\n\n\n2\n2\n\n\n3\n2\n\n\n4\n2\n\n\n5\n2\n\n\n6\n2\n\n\n7\n2\n\n\n8\n2\n\n\n9\n2\n\n\n10\n2\n\n\n11\n2\n\n\n12\n2\n\n\n13\n2\n\n\n14\n2\n\n\n15\n2\n\n\n16\n2\n\n\n17\n2\n\n\n18\n2\n\n\n19\n2\n\n\n20\n2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#penyelesaian-masalah-pemilihan-dan-penentuan-item-produksi",
    "href": "pre_5.html#penyelesaian-masalah-pemilihan-dan-penentuan-item-produksi",
    "title": "5  ompr PACKAGES di R",
    "section": "5.5 Penyelesaian Masalah Pemilihan dan Penentuan Item Produksi",
    "text": "5.5 Penyelesaian Masalah Pemilihan dan Penentuan Item Produksi\nDengan menggunakan library(ompr)\n\nrm(list=ls())\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n\n# data yang dibutuhkan\nprofit = c(5,7,3)\nsales = c(7,5,9)\nM = 99999\n\n# membuat model\nmil_prog = \n  MIPModel() %&gt;%\n  # menambah variabel\n  # xi\n  add_variable(x[i],\n           i = 1:3,\n           type = \"continuous\",\n           lb = 0) %&gt;%\n  # yi\n  add_variable(y[i],\n           i = 1:3,\n           type = \"binary\",\n           lb = 0) %&gt;%\n  # z\n  add_variable(z,type = \"binary\",lb = 0) %&gt;%\n  # membuat objective function\n  set_objective(sum_expr(x[i] * profit[i],\n             i = 1:3),\n        \"max\") %&gt;%\n  # menambah constraints\n  # max tonase\n  add_constraint(x[i] &lt;= sales[i],\n         i = 1:3) %&gt;%\n  # memilih 2 produk\n  add_constraint(x[i] - y[i] * M &lt;= 0,\n         i = 1:3) %&gt;%\n  add_constraint(sum_expr(y[i],\n         i = 1:3) &lt;= 2) %&gt;%\n  # memilih 1 plant\n  add_constraint(3*x[1] + 4*x[2] + 2*x[3] - M * z &lt;= 30) %&gt;%\n  add_constraint(4*x[1] + 6*x[2] + 2*x[3] + M * z &lt;= 40 + M) \n\nmil_prog\n\nMixed integer linear optimization problem\nVariables:\n  Continuous: 3 \n  Integer: 0 \n  Binary: 4 \nModel sense: maximize \nConstraints: 9 \n\nhasil = \n  mil_prog %&gt;%\n  solve_model(with_ROI(solver = \"glpk\",\n               verbose = T))\n\n&lt;SOLVER MSG&gt;  ----\nGLPK Simplex Optimizer 5.0\n9 rows, 7 columns, 20 non-zeros\n*     0: obj =  -0.000000000e+00 inf =   0.000e+00 (3)\n*     7: obj =   9.700000000e+01 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer 5.0\n9 rows, 7 columns, 20 non-zeros\n4 integer variables, all of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+     7: mip =     not found yet &lt;=              +inf        (1; 0)\n+    12: &gt;&gt;&gt;&gt;&gt;   5.450000000e+01 &lt;=   5.450000000e+01   0.0% (4; 0)\n+    12: mip =   5.450000000e+01 &lt;=     tree is empty   0.0% (0; 7)\nINTEGER OPTIMAL SOLUTION FOUND\n&lt;!SOLVER MSG&gt; ----\n\nxi = \n  hasil %&gt;% \n  get_solution(x[i])\n\nyi = \n  hasil %&gt;%\n  get_solution(y[i])\n\nzi = \n  hasil %&gt;%\n  get_solution(z)\n\nBerikut adalah hasilnya:\n\n\n  variable i value\n1        x 1   5.5\n2        x 2   0.0\n3        x 3   9.0\n\n\n  variable i value\n1        y 1     1\n2        y 2     0\n3        y 3     1\n\n\nz \n1 \n\n\nDari ketiga produk baru, perusahaan bisa memilih produk 1 dan 3 sebanyak 5.5 dan 9 ton di plant 2. Maka profit yang bisa diraih adalah sebesar 54.5.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#penyelesaian-masalah-knapsack-problem",
    "href": "pre_5.html#penyelesaian-masalah-knapsack-problem",
    "title": "5  ompr PACKAGES di R",
    "section": "5.6 Penyelesaian Masalah Knapsack Problem",
    "text": "5.6 Penyelesaian Masalah Knapsack Problem\nDalam knapsack problem, Anda perlu mengemas sejumlah barang dengan nilai dan ukuran tertentu (seperti berat atau volume) ke dalam sebuah wadah yang memiliki kapasitas maksimum. Apabila total ukuran barang melebihi kapasitas wadah, tentu tidak semua barang dapat dimasukkan.\nDalam situasi demikian, tantangannya adalah memilih subset barang yang memiliki total nilai tertinggi, namun masih dapat ditampung oleh wadah tersebut. Dengan kata lain, tujuan utamanya adalah mengoptimalkan nilai barang yang dibawa tanpa melampaui batas kapasitas yang tersedia.\n\nMemaksimalkan values dengan batasan weights.\n\n\nvalues = c(\n  360, 83, 59, 130, 431, 67, 230, 52, 93, 125, 670, 892, 600, 38, 48, 147,\n  78, 256, 63, 17, 120, 164, 432, 35, 92, 110, 22, 42, 50, 323, 514, 28,\n  87, 73, 78, 15, 26, 78, 210, 36, 85, 189, 274, 43, 33, 10, 19, 389, 276,\n  312)\nweights = c(7, 0, 30, 22, 80, 94, 11, 81, 70, 64, 59, 18, 0, 36, 3, 8, 15, 42, 9, 0,\n            42, 47, 52, 32, 26, 48, 55, 6, 29, 84, 2, 4, 18, 56, 7, 29, 93, 44, 71,\n            3, 86, 66, 31, 65, 0, 79, 20, 65, 52, 13)\n\ndf          = data.frame(values,weights)\nbatas_berat = 850\n\nbin_prog = \n  MIPModel() %&gt;%\n  # menambah variabel\n  add_variable(x[i],i = 1:50,type = \"binary\") |&gt; \n  # objective function\n  set_objective(sum_expr(x[i] * values[i],i = 1:50),\"max\") |&gt; \n  # tambah constraints\n  add_constraint(sum_expr(x[i] * weights[i],i = 1:50) &lt;= batas_berat)\n\nbin_prog \n\nMixed integer linear optimization problem\nVariables:\n  Continuous: 0 \n  Integer: 0 \n  Binary: 50 \nModel sense: maximize \nConstraints: 1 \n\nhasil = \n  bin_prog %&gt;%\n  solve_model(with_ROI(solver = \"glpk\",\n                       verbose = T))\n\n&lt;SOLVER MSG&gt;  ----\nGLPK Simplex Optimizer 5.0\n1 row, 50 columns, 46 non-zeros\n*     0: obj =  -0.000000000e+00 inf =   0.000e+00 (50)\n*    37: obj =   7.566857143e+03 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer 5.0\n1 row, 50 columns, 46 non-zeros\n50 integer variables, all of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+    37: mip =     not found yet &lt;=              +inf        (1; 0)\nSolution found by heuristic: 7517\nSolution found by heuristic: 7526\n+    46: &gt;&gt;&gt;&gt;&gt;   7.534000000e+03 &lt;=   7.541000000e+03 &lt; 0.1% (4; 4)\n+    48: mip =   7.534000000e+03 &lt;=     tree is empty   0.0% (0; 15)\nINTEGER OPTIMAL SOLUTION FOUND\n&lt;!SOLVER MSG&gt; ----\n\nhasil\n\nStatus: success\nObjective value: 7534\n\nhasil %&gt;% \n  get_solution(x[i]) |&gt; \n  gt() %&gt;%\n  gt_theme_538() |&gt; \n  tab_header(title = \"Konfigurasi Item yang Dipilih\",\n             subtitle = \"Solusi optimal dari ompr\")\n\n\n\n\n\n\n\nKonfigurasi Item yang Dipilih\n\n\nSolusi optimal dari ompr\n\n\nvariable\ni\nvalue\n\n\n\n\nx\n1\n1\n\n\nx\n2\n1\n\n\nx\n3\n0\n\n\nx\n4\n1\n\n\nx\n5\n1\n\n\nx\n6\n0\n\n\nx\n7\n1\n\n\nx\n8\n0\n\n\nx\n9\n0\n\n\nx\n10\n0\n\n\nx\n11\n1\n\n\nx\n12\n1\n\n\nx\n13\n1\n\n\nx\n14\n0\n\n\nx\n15\n1\n\n\nx\n16\n1\n\n\nx\n17\n1\n\n\nx\n18\n1\n\n\nx\n19\n1\n\n\nx\n20\n1\n\n\nx\n21\n0\n\n\nx\n22\n1\n\n\nx\n23\n1\n\n\nx\n24\n0\n\n\nx\n25\n1\n\n\nx\n26\n0\n\n\nx\n27\n0\n\n\nx\n28\n1\n\n\nx\n29\n1\n\n\nx\n30\n1\n\n\nx\n31\n1\n\n\nx\n32\n1\n\n\nx\n33\n1\n\n\nx\n34\n0\n\n\nx\n35\n1\n\n\nx\n36\n0\n\n\nx\n37\n0\n\n\nx\n38\n0\n\n\nx\n39\n1\n\n\nx\n40\n1\n\n\nx\n41\n0\n\n\nx\n42\n1\n\n\nx\n43\n1\n\n\nx\n44\n0\n\n\nx\n45\n1\n\n\nx\n46\n0\n\n\nx\n47\n0\n\n\nx\n48\n1\n\n\nx\n49\n1\n\n\nx\n50\n1\n\n\n\n\n\n\nx_i = \n  hasil %&gt;% \n  get_solution(x[i]) |&gt; \n  pull(value)\n\ndf |&gt; \n  mutate(x_i = x_i) |&gt; \n  group_by(x_i) |&gt; \n  reframe(berat = sum(weights),\n          nilai = sum(values)) |&gt; \n  filter(x_i == 1)\n\n# A tibble: 1 × 3\n    x_i berat nilai\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1   850  7534\n\n\nKita dapatkan konfigurasi item terpilih yang memaksimalkan values.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_5.html#footnotes",
    "href": "pre_5.html#footnotes",
    "title": "5  ompr PACKAGES di R",
    "section": "",
    "text": "https://www.r-orms.org/↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>`ompr` _PACKAGES_ di __R__</span>"
    ]
  },
  {
    "objectID": "pre_6.html",
    "href": "pre_6.html",
    "title": "6  SPIRAL OPTIMIZATION ALGORITHM",
    "section": "",
    "text": "6.1 Ilustrasi Geometris\nSpiral Optimization Algorithm adalah salah satu metode meta heuristic yang digunakan untuk mencari minimum global dari suatu sistem persamaan.\nAlgoritmanya mudah dipahami dan intuitif tanpa harus memiliki latar keilmuan tertentu. Proses kerjanya adalah dengan melakukan random number generating pada suatu selang dan melakukan rotasi sekaligus kontraksi dengan titik paling minimum pada setiap iterasi sebagai pusatnya.\nBerikut adalah algoritmanya:\nBerdasarkan algoritma di atas, salah satu proses yang penting adalah melakukan rotasi dan konstraksi terhadap semua titik yang telah di-generate.\nAgar memudahkan penjeasan, saya akan memberikan ilustrasi geometri beserta operasi matriks aljabar terkait kedua hal tersebut.\nBerikut adalah langkah-langkah yang ditempuh:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>_SPIRAL OPTIMIZATION ALGORITHM_</span>"
    ]
  },
  {
    "objectID": "pre_6.html#ilustrasi-geometris",
    "href": "pre_6.html#ilustrasi-geometris",
    "title": "6  SPIRAL OPTIMIZATION ALGORITHM",
    "section": "",
    "text": "6.1.1 Operasi Matriks Rotasi\nMisalkan saya memiliki titik \\(x \\in \\mathbb{R}^2\\). Untuk melakukan rotasi sebesar \\(\\theta\\), saya bisa menggunakan suatu matriks \\(A_{2 \\times 2}\\) berisi fungsi-fungsi trigonometri sebagai berikut:\n\\[\\begin{bmatrix} x_1 (k+1) \\\\ x_2 (k+1) \\end{bmatrix} = \\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} \\\\ \\sin{\\theta} & \\cos{\\theta} \\end{bmatrix} \\begin{bmatrix} x_1 (k) \\\\ x_2 (k) \\end{bmatrix}\\]\n\n\n6.1.2 Operasi Matriks Rotasi dan Kontraksi\nJika pada sebelumnya saya hanya melakukan rotasi, kali ini saya akan memodifikasi operasi matriks agar melakukan rotasi dan konstraksi secara bersamaan. Untuk melakukan hal tersebut, saya akan definisikan \\(r,0&lt;r&lt;1\\) dan melakukan operasi matriks sebagai berikut:\n\\[\\begin{bmatrix} x_1 (k+1) \\\\ x_2 (k+1) \\end{bmatrix} = \\begin{bmatrix} r \\\\ r \\end{bmatrix} \\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} \\\\ \\sin{\\theta} & \\cos{\\theta} \\end{bmatrix} \\begin{bmatrix} x_1 (k) \\\\ x_2 (k) \\end{bmatrix}\\]\n\n\n6.1.3 Operasi Matriks Rotasi dan Kontraksi dengan Titik \\(x^*\\) Sebagai Pusatnya\nSalah satu prinsip utama dari spiral optimization algorithm adalah menjadikan titik \\(x^*\\) sebagai pusat rotasi di setiap iterasinya. Operasi matriksnya adalah sebagai berikut:\n\\[\\begin{bmatrix} x_1 (k+1) \\\\ x_2 (k+1) \\end{bmatrix} = \\begin{bmatrix} x_1^* \\\\ x_2^* \\end{bmatrix} + \\begin{bmatrix} r \\\\ r \\end{bmatrix} \\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} \\\\ \\sin{\\theta} & \\cos{\\theta} \\end{bmatrix} ( \\begin{bmatrix} x_1 (k) \\\\ x_2 (k) \\end{bmatrix} - \\begin{bmatrix} x_1^* \\\\ x_2^* \\end{bmatrix} )\\] ## Matriks Rotasi untuk n-Dimensi\nSOA relatif mudah untuk dituliskan dalam bentuk algoritma bahasa pemrograman manapun. Tapi ada satu hal yang bisa menjadi batu ganjalan dalam menuliskan algoritmanya. Apa itu? Yaitu pendefinisian matriks rotasi untuk masalah dengan n-dimensi.\nBentuk umum dari matriks rotasi adalah sebagai berikut:\n\\[R^{(n)} (\\theta_{1,2},\\theta_{1,3},..,\\theta_{n,n-1}) = \\prod_{i=1}^{n-1} \\left ( \\prod_{j=1}^i R^{(n)}_{n-i,n+1-j} (\\theta_{n-i,n+1-j}) \\right )\\]\nPerhatikan bahwa perkalian matriks rotasi yang dilakukan adalah cross product.\nAlasan: Rotasi tidak mengubah norm suatu vektor.\n\n\n6.1.4 Function Matriks Rotasi\nBerikut adalah function yang digunakan untuk membuat rotation matrix:\n\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n\n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  \n  return(mat_rot)\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>_SPIRAL OPTIMIZATION ALGORITHM_</span>"
    ]
  },
  {
    "objectID": "pre_6.html#milp-dengan-dynamic-spiral-optimization-algorithm",
    "href": "pre_6.html#milp-dengan-dynamic-spiral-optimization-algorithm",
    "title": "6  SPIRAL OPTIMIZATION ALGORITHM",
    "section": "6.2 MILP dengan Dynamic Spiral Optimization Algorithm",
    "text": "6.2 MILP dengan Dynamic Spiral Optimization Algorithm\nSalah satu trik yang bisa dilakukan agar SOA bisa menyelesaikan mixed integer programming adalah dengan mengubah constrained optimization problem menjadi unconstrained optimization problem kemudian memanfaatkan penalty constant.\nMisal suatu permasalahan MILP atau MINLP bisa ditulis secara umum sebagai berikut:\n\\[\\min_{x \\in \\mathbb{R}^n} f(x)\\]\n\\[\\text{subject to: } g_i(x) = 0, i = 1,2,..,M\\]\n\\[\\text{and } h_j(x) \\leq 0,i = 1,2,..,N\\]\n\\[x = (x_1,x_2,...,x_n)^T \\in \\mathbb{N}\\]\nBentuk di atas bisa kita ubah menjadi:\n\\[F(x,\\alpha,\\beta) = f(x) + \\sum_{i=1}^M \\alpha_i g_i^2(x) + \\sum_{j = 1}^N \\beta_j (\\max{(h_i(x),0)})^2\\]\ndimana \\(\\alpha,\\beta\\) merupakan penalty constant yang bisa dibuat sangat besar.\n\n6.2.1 Penyelesaian MILP\nCari \\(x_1,x_2,x_3\\) yang memaksimalkan \\(7x_1 + 3x_2 + x_3\\), dengan constraints sebagai berikut:\n\\[6x_1 + 4x_2 + 5x_3 \\leq 60\\]\n\\[8x_1 + x_2 + 2x_3 \\leq 80\\]\n\\[9x_1 + x_2 + 7x_3 \\leq 70\\]\n\\[x_3 \\geq 0\\]\n\\[x_1,x_2 \\in \\mathbb{Z}^+\\]\nMasalah di atas termasuk ke dalam mixed integer linear programming karena ada dua variabel integer dan satu kontinu.\nBerikut adalah modifikasi menjadi unconstrained optimization problem:\n\nrm(list=ls())\n\nlibrary(dplyr)\nlibrary(tidyr)\n\nf1 = function(x1,x2,x3){\n  7*x1 + 3*x2 + x3\n}\n\nh1 = function(x1,x2,x3){6*x1 + 4*x2 + 5*x3 - 60}\nh2 = function(x1,x2,x3){8*x1 + x2 + 2*x3 - 80}\nh3 = function(x1,x2,x3){9*x1 + x2 + 7*x3 - 70}\n\nbeta = 10^15\n\nf = function(x1,x2,x3){\n  el_1 = - f1(x1,x2,x3) \n  el_2 = beta * (max(h1(x1,x2,x3),0))^2\n  el_3 = beta * (max(h2(x1,x2,x3),0))^2\n  el_4 = beta * (max(h3(x1,x2,x3),0))^2\n  return(el_1 + el_2 + el_3 + el_4)\n}\n\nBerikut adalah function yang digunakan:\n\nsoa_mrf_ip_3_var = function(\n  N,        # banyak titik\n  x1_d,  # batas bawah x1  \n  x1_u,  # batas atas x1\n  x2_d,  # batas bawah x2\n  x2_u,  # batas atas x2\n  x3_d,  # batas bawah x3\n  x3_u,  # batas atas x3\n  rot,   # berapa banyak rotasi\n  k_max, # iterasi maks\n  r){      # berapa rate konstraksi\n  \n  # N pasang titik random di selang [a,b] di R3\n  x1 = runif(N,x1_d,x1_u)\n  x2 = runif(N,x2_d,x2_u)\n  x3 = runif(N,x3_d,x3_u)\n  \n  # hitung theta\n  theta = 2*pi / rot\n  # definisi matriks rotasi\n  R12 = matrix(c(cos(theta),-sin(theta),0,\n                 sin(theta),cos(theta),0,\n                 0,0,1),\n               ncol = 3,byrow = T)\n  R13 = matrix(c(cos(theta),0,-sin(theta),\n                 0,1,0,\n                 sin(theta),0,cos(theta)),\n               ncol = 3,byrow = T)\n  R23 = matrix(c(1,0,0,\n                 0,cos(theta),-sin(theta),\n                 0,sin(theta),cos(theta)),\n               ncol = 3,byrow = T)\n  \n  \n  # bikin data frame\n  temp = \n    data.frame(x1,x2,x3) %&gt;% \n    rowwise() %&gt;% \n    mutate(f = f(round(x1,0),\n                 round(x2,0),\n                 x3)) %&gt;% \n    ungroup()\n  \n  # proses iterasi\n  for(i in 1:k_max){\n    # mencari titik x* dengan max(f)\n    f_min = \n      temp %&gt;% \n      # memastikan titik ada di D\n      filter(x1 &gt;= x1_d & x1 &lt;= x1_u) %&gt;% \n      filter(x2 &gt;= x2_d & x2 &lt;= x2_u) %&gt;% \n      filter(x3 &gt;= x3_d & x3 &lt;= x3_u) %&gt;% \n      # mencari titik max fungsi\n      filter(f == min(f))\n    # definisi pusat rotasi\n    pusat = c(f_min$x1[1],f_min$x2[1],f_min$x3[1])\n    for(j in 1:N){\n      # kita akan ambil titiknya satu persatu\n      x0 = c(temp$x1[j],temp$x2[j],temp$x3[j])\n      # proses rotasi dan konstraksi terhadap pusat x*\n      # diputar dengan x_bin sebagai pusat\n      xk = (R23 %*% (R13 %*% R12)) %*% (x0-pusat)\n      xk = pusat + (r * xk)\n      # proses mengembalikan nilai ke temp\n      temp$x1[j] = xk[1]\n      temp$x2[j] = xk[2]\n      temp$x3[j] = xk[3]\n    }\n    # hitung kembali nilai f(x1,x2,x3)\n    temp = \n      temp %&gt;% \n      rowwise() %&gt;% \n      mutate(f = f(round(x1,0),round(x2,0),x3)) %&gt;% \n      ungroup()\n  }\n  # proses output hasil\n  output = \n    temp[N,] %&gt;% \n    filter(f == max(f)) %&gt;% \n    mutate(x1 = round(x1,0),x2 = round(x2,0),x3 = x3,\n           f = f1(x1,x2,x3))\n  return(output)\n}\n\nBerikut solusinya:\n\nsoa_mrf_ip_3_var(\n  20,       # banyak titik\n  0,  # batas bawah x1  \n  20,  # batas atas x1\n  0,  # batas bawah x2\n  20,  # batas atas x2\n  0,  # batas bawah x3\n  20,  # batas atas x3\n  10,     # berapa banyak rotasi\n  100, # iterasi maks\n  .9\n)\n\n# A tibble: 1 × 4\n     x1    x2    x3     f\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     7     4 0.400  61.4",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>_SPIRAL OPTIMIZATION ALGORITHM_</span>"
    ]
  },
  {
    "objectID": "pre_6.html#conclusion",
    "href": "pre_6.html#conclusion",
    "title": "6  SPIRAL OPTIMIZATION ALGORITHM",
    "section": "6.3 Conclusion",
    "text": "6.3 Conclusion\nUntuk bisa menuliskan skrip spiral, hal yang perlu diperhatikan adalah:\n\nPendefinisian matriks rotasi.\nPendefinisian fungsi objektif.\nPemilihan parameter spiral seperti sudut rotasi, berapa besar konstraksi, dan iterasi maksimal.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>_SPIRAL OPTIMIZATION ALGORITHM_</span>"
    ]
  },
  {
    "objectID": "pre_7.html",
    "href": "pre_7.html",
    "title": "7  or tools GOOGLE PYTHON",
    "section": "",
    "text": "7.1 Instalasi or tools\nOR-Tools (Operations Research Tools) adalah library open-source buatan Google yang dikembangkan untuk menyelesaikan masalah optimasi kombinatorial dan pemrograman matematika. Diluncurkan sekitar tahun 2010, library ini dirancang untuk menjadi alat yang scalable dan efisien dalam menyelesaikan masalah kompleks seperti routing kendaraan, penjadwalan, penugasan, dan optimasi linear. OR-Tools dibangun berdasarkan pengalaman internal Google dalam menangani masalah optimasi skala besar dan menggabungkan berbagai state-of-the-art solver serta algoritma heuristik.\nYang membuat OR-Tools istimewa adalah dukungannya terhadap multiple programming languages (C++, Python, Java, C#), fleksibilitas dalam pemodelan masalah, dan kemampuan untuk menangani berbagai tipe masalah optimasi seperti linear programming, constraint programming, dan mixed-integer programming. Library ini tidak hanya menyediakan solver internal yang powerful tetapi juga dapat terintegrasi dengan solver eksternal seperti SCIP, GLPK, dan CP-SAT, menjadikannya pilihan populer baik untuk penelitian akademis maupun aplikasi industri skala enterprise.\nJangan lupa untuk menginstall ortools di terminal:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`or tools` GOOGLE __*PYTHON*__</span>"
    ]
  },
  {
    "objectID": "pre_7.html#instalasi-or-tools",
    "href": "pre_7.html#instalasi-or-tools",
    "title": "7  or tools GOOGLE PYTHON",
    "section": "",
    "text": "pip install ortools",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`or tools` GOOGLE __*PYTHON*__</span>"
    ]
  },
  {
    "objectID": "pre_7.html#penyelesaian-masalah-knapsack-problem",
    "href": "pre_7.html#penyelesaian-masalah-knapsack-problem",
    "title": "7  or tools GOOGLE PYTHON",
    "section": "7.2 Penyelesaian Masalah Knapsack Problem",
    "text": "7.2 Penyelesaian Masalah Knapsack Problem\nBerikut adalah skrip di Python nya:\nfrom ortools.linear_solver import pywraplp\n\ndef solve_milp():\n    # Membuat solver\n    solver = pywraplp.Solver.CreateSolver('SCIP')\n    \n    # Membuat variabel\n    x = {}\n    y = {}\n    for i in range(1, 3):\n        x[i] = solver.IntVar(0, solver.infinity(), f'x_{i}')\n        y[i] = solver.BoolVar(f'y_{i}')\n    \n    # Membuat objective function\n    objective = solver.Objective()\n    objective.SetCoefficient(x[1], 400000)\n    objective.SetCoefficient(x[2], 250000)\n    objective.SetCoefficient(y[1], -500000)\n    objective.SetCoefficient(y[2], -300000)\n    objective.SetMaximization()\n    \n    # Menambah constraints\n    # Constraint 1: 4*x1 + 2*x2 &lt;= 100\n    constraint1 = solver.Constraint(-solver.infinity(), 100)\n    constraint1.SetCoefficient(x[1], 4)\n    constraint1.SetCoefficient(x[2], 2)\n    \n    # Constraint 2: 2*x1 + 3*x2 &lt;= 90\n    constraint2 = solver.Constraint(-solver.infinity(), 90)\n    constraint2.SetCoefficient(x[1], 2)\n    constraint2.SetCoefficient(x[2], 3)\n    \n    # Constraint 3: 5*x1 + 3*x2 &lt;= 120\n    constraint3 = solver.Constraint(-solver.infinity(), 120)\n    constraint3.SetCoefficient(x[1], 5)\n    constraint3.SetCoefficient(x[2], 3)\n    \n    # Constraint 4: x1 &lt;= 1000*y1\n    constraint4 = solver.Constraint(-solver.infinity(), 0)\n    constraint4.SetCoefficient(x[1], 1)\n    constraint4.SetCoefficient(y[1], -1000)\n    \n    # Constraint 5: x2 &lt;= 1000*y2\n    constraint5 = solver.Constraint(-solver.infinity(), 0)\n    constraint5.SetCoefficient(x[2], 1)\n    constraint5.SetCoefficient(y[2], -1000)\n    \n    # Solve the problem\n    status = solver.Solve()\n    \n    # Print results\n    if status == pywraplp.Solver.OPTIMAL:\n        print('Solution:')\n        print('Objective value =', solver.Objective().Value())\n        for i in range(1, 3):\n            print(f'x[{i}] =', x[i].solution_value())\n        for i in range(1, 3):\n            print(f'y[{i}] =', int(y[i].solution_value()))\n    else:\n        print('The problem does not have an optimal solution.')\n\n# Run the solver\nsolve_milp()\nKita dapatkan hasil yang sama, yakni:\nSolution:\nObjective value = 9100000.000000002\nx[1] = 24.0\nx[2] = 0.0\ny[1] = 1\ny[2] = 0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`or tools` GOOGLE __*PYTHON*__</span>"
    ]
  },
  {
    "objectID": "pre_8.html",
    "href": "pre_8.html",
    "title": "8  PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI",
    "section": "",
    "text": "8.1 Regresi Linear\nTernyata beberapa masalah umum seperti machine learning (baik supervised atau unsupervised) bisa dipandang sebagai masalah optimisasi.\nMisalkan kita memiliki data sebagai berikut:\nrm(list=ls())\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(gt)\nlibrary(gtExtras)\n\ndf = mtcars |&gt; select(qsec,disp,mpg,wt,hp)\n\ndf |&gt; \n  gt() %&gt;%\n  gt_theme_538() |&gt; \n  tab_header(title = \"Data Contoh untuk Regresi\",\n             subtitle = \"Diambil dari Data mcars\")\n\n\n\n\n\n\n\nData Contoh untuk Regresi\n\n\nDiambil dari Data mcars\n\n\nqsec\ndisp\nmpg\nwt\nhp\n\n\n\n\n16.46\n160.0\n21.0\n2.620\n110\n\n\n17.02\n160.0\n21.0\n2.875\n110\n\n\n18.61\n108.0\n22.8\n2.320\n93\n\n\n19.44\n258.0\n21.4\n3.215\n110\n\n\n17.02\n360.0\n18.7\n3.440\n175\n\n\n20.22\n225.0\n18.1\n3.460\n105\n\n\n15.84\n360.0\n14.3\n3.570\n245\n\n\n20.00\n146.7\n24.4\n3.190\n62\n\n\n22.90\n140.8\n22.8\n3.150\n95\n\n\n18.30\n167.6\n19.2\n3.440\n123\n\n\n18.90\n167.6\n17.8\n3.440\n123\n\n\n17.40\n275.8\n16.4\n4.070\n180\n\n\n17.60\n275.8\n17.3\n3.730\n180\n\n\n18.00\n275.8\n15.2\n3.780\n180\n\n\n17.98\n472.0\n10.4\n5.250\n205\n\n\n17.82\n460.0\n10.4\n5.424\n215\n\n\n17.42\n440.0\n14.7\n5.345\n230\n\n\n19.47\n78.7\n32.4\n2.200\n66\n\n\n18.52\n75.7\n30.4\n1.615\n52\n\n\n19.90\n71.1\n33.9\n1.835\n65\n\n\n20.01\n120.1\n21.5\n2.465\n97\n\n\n16.87\n318.0\n15.5\n3.520\n150\n\n\n17.30\n304.0\n15.2\n3.435\n150\n\n\n15.41\n350.0\n13.3\n3.840\n245\n\n\n17.05\n400.0\n19.2\n3.845\n175\n\n\n18.90\n79.0\n27.3\n1.935\n66\n\n\n16.70\n120.3\n26.0\n2.140\n91\n\n\n16.90\n95.1\n30.4\n1.513\n113\n\n\n14.50\n351.0\n15.8\n3.170\n264\n\n\n15.50\n145.0\n19.7\n2.770\n175\n\n\n14.60\n301.0\n15.0\n3.570\n335\n\n\n18.60\n121.0\n21.4\n2.780\n109\nLalu kita mau membuat model regresi:\n\\[qsec \\simeq y_1 disp + y_2 mpg + y_3 wt + y_4 hp + y_5\\]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_8.html#regresi-linear",
    "href": "pre_8.html#regresi-linear",
    "title": "8  PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI",
    "section": "",
    "text": "8.1.1 base di R\nJika ingin diselesaikan dengan base di R, kita bisa menggunakan skrip berikut ini:\n\nmodel = lm(qsec ~ .,data = df)\nmodel\n\n\nCall:\nlm(formula = qsec ~ ., data = df)\n\nCoefficients:\n(Intercept)         disp          mpg           wt           hp  \n  14.693469    -0.006539     0.088170     1.820406    -0.020206  \n\nsummary(model)\n\n\nCall:\nlm(formula = qsec ~ ., data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.5855 -0.4517 -0.0455  0.3609  3.3023 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 14.693469   2.928944   5.017 2.91e-05 ***\ndisp        -0.006539   0.004140  -1.580 0.125860    \nmpg          0.088170   0.075585   1.166 0.253616    \nwt           1.820406   0.514181   3.540 0.001472 ** \nhp          -0.020206   0.005145  -3.928 0.000536 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.055 on 27 degrees of freedom\nMultiple R-squared:  0.6961,    Adjusted R-squared:  0.6511 \nF-statistic: 15.46 on 4 and 27 DF,  p-value: 1.079e-06\n\n\nKita bisa dapatkan \\(R^2 \\simeq 0.6\\).\n\n\n8.1.2 Mengubahnya Menjadi Optimisasi dengan ompr\nPerhatikan bahwa saat kita membuat model regresi:\n\\[qsec \\simeq y_1 disp + y_2 mpg + y_3 wt + y_4 hp + y_5\\]\nDefinisikan:\n\n\\(\\hat{qsec}\\) yang merupakan hasil prediksi dari nilai actual \\(qsec\\).\n\\(\\epsilon\\) merupakan error (selisih) antara actual dan predict.\n\nKita sangat berharap bahwa: \\(\\epsilon = |\\hat{qsec} - qsec|\\) sangat kecil atau minimum.\nMaka kita bisa pandang pencarian bobot regresi (\\(y_1,y_2,y_3,y_4,y_5\\)) sebagai masalah optimisasi (minimasi).\nKita bisa tuliskan decision variables sebagai berikut:\n\n\\(y_i,i = 1,..,5\\) yang merupakan variabel bobot regresi.\n\\(t_j,j = 1,..,32\\) sebagai error yang dihasilkan antara actual dan predict di setiap baris data \\(j\\).\n\nMaka model optimisasinya:\n\\[\\min{\\sum_i^{32} t_j}\\]\nDengan constraints:\n\\[y_1 disp_j + y_2 mpg_j + y_3 wt_j + y_4 hp_j + y_5 \\le t_j\\]\n\\[y_1 disp_j + y_2 mpg_j + y_3 wt_j + y_4 hp_j + y_5 \\ge -t_j\\]\nBerikut ini adalah skripnya jika dituliskan dalam ompr:\n\nlibrary(parallel)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n\ntarget = df$qsec\nx1 = df$disp\nx2 = df$mpg\nx3 = df$wt\nx4 = df$hp\nx5 = 1\n\n\n# Alternatif yang lebih compact\nmodel_compact &lt;- MIPModel() %&gt;%\n  add_variable(y[i],i = 1:5, type = \"continuous\") %&gt;%\n  add_variable(t[j], j = 1:32, type = \"continuous\", lb = 0) %&gt;%  # absolute error\n  \n  # Constraints: -t_i ≤ (y_i - (a*x1_i + b*x2_i + x3_i)) ≤ t_i\n  add_constraint(\n    y[1]*x1[j]+y[2]*x2[j]+y[3]*x3[j]+y[4]*x4[j]+y[5]*x5 - target[j] &lt;= t[j],\n    j = 1:32\n  ) %&gt;%\n  add_constraint(\n    y[1]*x1[j]+y[2]*x2[j]+y[3]*x3[j]+y[4]*x4[j]+y[5]*x5 - target[j] &gt;= -t[j],\n    j = 1:32\n  ) %&gt;%\n  \n  set_objective(sum_expr(t[i], i = 1:32), \"min\")\n\nresult_compact &lt;- solve_model(model_compact, with_ROI(solver = \"glpk\"))\n\nBerikut ini adalah koefisien regresi yang dihasilkan:\n\nkoef = result_compact %&gt;% get_solution(y[i]) |&gt; pull(value)\n\ndata.frame(variabel = paste0(\"x_\",1:5),\n           koef) |&gt; \n  gt() %&gt;% \n  gt_theme_538() %&gt;% \n  tab_header(title = \"Koefisien Regresi Hasil Optimisasi\")\n\n\n\n\n\n\n\nKoefisien Regresi Hasil Optimisasi\n\n\nvariabel\nkoef\n\n\n\n\nx_1\n-0.006733834\n\n\nx_2\n0.057643063\n\n\nx_3\n1.534006134\n\n\nx_4\n-0.018522667\n\n\nx_5\n15.980000019\n\n\n\n\n\n\n\nSaya akan hitung mean absolute error dan \\(R^2\\) yang dihasilkan:\n\ndf = \n  df |&gt; \n  mutate(pred = disp * koef[1] + mpg * koef[2] + wt * koef[3] + hp * koef[4] + koef[5]) \n  \nMetrics::mae(df$qsec,df$pred)\n\n[1] 0.6442972\n\ncaret::R2(df$qsec,df$pred)\n\n[1] 0.6913459",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_8.html#clustering-analysis",
    "href": "pre_8.html#clustering-analysis",
    "title": "8  PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI",
    "section": "8.2 Clustering Analysis",
    "text": "8.2 Clustering Analysis\nBerikut adalah salah satu contoh bagaimana optimisasi bisa digunakan untuk membuat cluster atau kelompok data.\n\n8.2.1 factoextra di R\nBerikut adalah contoh clustering analysis dengan \\(k=4\\) menggunakan library(factoextra) di R:\n\nrm(list=ls())\n\nmtcars_scaled &lt;- scale(mtcars)\n\n# K-means dengan optimasi jumlah cluster\nlibrary(factoextra)\nfviz_nbclust(mtcars_scaled, kmeans, method = \"wss\") # Elbow method\n\n\n\n\n\n\n\nfviz_nbclust(mtcars_scaled, kmeans, method = \"silhouette\") # Silhouette method\n\n\n\n\n\n\n\n# Final k-means clustering\nset.seed(123)\noptimal_k &lt;- 4  # Dari analisis di atas\nkmeans_result &lt;- kmeans(mtcars_scaled, centers = optimal_k, nstart = 25)\nkmeans_result$centers\n\n         mpg        cyl        disp         hp        drat          wt\n1  0.1082193 -0.5849321 -0.44867013 -0.6496905 -0.04967936 -0.02346989\n2 -0.2639188  0.3429602 -0.05907659  0.7600688  0.44781564 -0.22101115\n3  1.3247791 -1.2248578 -1.10626771 -0.9453003  1.09820619 -1.20086981\n4 -0.8363478  1.0148821  1.02385129  0.6924910 -0.88974768  0.90635862\n        qsec         vs         am       gear       carb\n1  1.1854841  1.1160357 -0.8141431 -0.1573201 -0.4145882\n2 -1.2494801 -0.8680278  1.1899014  1.2367782  1.4781451\n3  0.3364684  0.8680278  1.1899014  0.7623975 -0.8125929\n4 -0.3952280 -0.8680278 -0.8141431 -0.9318192  0.1676779\n\nkmeans_result$cluster |&gt; table()\n\n\n 1  2  3  4 \n 7  5  8 12 \n\nsummary(kmeans_result)\n\n             Length Class  Mode   \ncluster      32     -none- numeric\ncenters      44     -none- numeric\ntotss         1     -none- numeric\nwithinss      4     -none- numeric\ntot.withinss  1     -none- numeric\nbetweenss     1     -none- numeric\nsize          4     -none- numeric\niter          1     -none- numeric\nifault        1     -none- numeric\n\nkmeans_result$tot.withinss\n\n[1] 86.81903\n\n\n\n\n8.2.2 Clustering dengan Spiral Dynamic\nKita bisa melakukan clustering analysis dengan mendefinisikan fungsi objektif sebagai berikut:\n\nRata-rata jarak antar titik di satu cluster yang sama harus sekecil-kecilnya.\nJarak antar cluster centers itu harus semaksimal mungkin.\nTidak boleh ada satu cluster yang hanya memiliki satu cluster member saja.\nBanyaknya cluster dijaga agar tetap 4.\n\nKita bisa tuliskan model matematisnya:\n\\[f_1: \\text{fungsi objektif jarak antar titik dalam cluster}\\]\n\\[f_2: \\text{fungsi objektif jarak antar cluster centers}\\]\nMaka fungsi objektifnya saya definisikan sebagai:\n\\[\\min \\frac{f_1}{f_2}\\]\nBentuk skrip R-nya menjadi sebagai berikut:\n\nrm(list=ls())\ngc()\n\n          used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 2749585 146.9    5026442 268.5  5026442 268.5\nVcells 4798190  36.7   10146329  77.5  7903096  60.3\n\nlibrary(dplyr)\nlibrary(parallel)\nncore = detectCores()\n\n# Data preparation\ndata(mtcars)\nmtcars_scaled &lt;- scale(mtcars) |&gt; as.data.frame()\nn &lt;- nrow(mtcars_scaled)\nk &lt;- 4  # Number of clusters\n\n# generate calon\nbuat_bintang = function(){\n  sample(k,n,replace = T)\n}\n\n# Calculate distance matrix\nhitung_jarak = function(input){\n  output = dist(input,method = \"euclidean\") |&gt; mean()\n  output = ifelse(is.nan(output),1000,output)\n}\n\n# objective function\nobj_func = function(bintang){\n  split_df = \n    mtcars_scaled |&gt; \n    mutate(cluster = bintang) |&gt; \n    group_split(cluster)\n  f1 = lapply(split_df,hitung_jarak) |&gt; unlist() |&gt; sum()\n  \n  mat_f2 = \n    mtcars_scaled |&gt; \n    mutate(cluster = bintang) |&gt; \n    group_by(cluster) |&gt; \n    summarise_all(mean) |&gt; \n    ungroup() |&gt; \n    select(-cluster)\n  f2 = hitung_jarak(mat_f2)\n\n  n_cal = bintang |&gt; unique() |&gt; length()\n  skor  = (f1 + n_cal)/f2\n  return(skor)\n}\n\n# function matriks rotasi\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n  \n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  return(mat_rot)\n}\n\n# bikin matriks rotasinya\nA_rot = buat_rot_mat(2*pi/30,n)\n\n# kita mulai spiralnya\nN_spiral = ncore * 7\nid_calon = 1:N_spiral\ncalon = vector(\"list\",N_spiral)\nfor(i in 1:N_spiral){\n  calon[[i]] = buat_bintang()\n}\n\n# hitung f nya\nf_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\nfor(ikanx in 1:100){\n  # penentuan calon paling minimum\n  id_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n  # ambil komponen terkecil pertama saja\n  id_min = id_min[1]\n  pusat  = calon[[id_min]]\n  \n  loop = 1:N_spiral\n  loop = loop[-id_min]\n  # proses rotasi semua calon\n  for(i in loop){\n    Xt = calon[[i]]\n    X  = A_rot %*% (Xt - pusat)\n    X  = pusat + (.9 * X)\n    X  = ifelse(X &gt;= 4,1,X)\n    X  = ifelse(X &lt;= 1,4,X)\n    calon[[i]] = floor(X)\n    }\n  f_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\n}\n\n# penentuan solusi\nid_min   = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\ncluster_ = calon[[id_min]] %&gt;% floor()\n\nBerikut adalah berapa banyak cluster yang dihasilkan:\n\n# tabulasi berapa banyak id per cluster\ntable(cluster_)\n\ncluster_\n 1  2  3  4 \n14 13  3  2 \n\n\nNilai fungsi objektif yang dihasilkan:\n\n# nilai fungsi objektif yang dihasilkan\nmin(f_hit)\n\n[1] 4.679672\n\n\nBerikut ini adalah cluster centers-nya:\n\nmtcars_scaled |&gt; \n  mutate(cluster = cluster_) |&gt; \n  group_by(cluster) |&gt; \n  summarise_all(mean) |&gt; \n  ungroup() |&gt; \n  gt() |&gt; \n  gt_theme_538() |&gt; \n  tab_header(title = \"Cluster Centers\",\n             subtitle = \"Hasil Spiral Dynamic\")\n\n\n\n\n\n\n\nCluster Centers\n\n\nHasil Spiral Dynamic\n\n\ncluster\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n1\n-0.1667362\n0.2949657\n0.18355489\n0.12957347\n-0.05235120\n0.18378053\n-0.2599211\n-0.4428713\n0.04473314\n0.03630464\n0.20453018\n\n\n2\n-0.1056553\n-0.1911317\n-0.08235112\n0.05953267\n-0.03529258\n0.08968198\n0.3231238\n0.3529344\n-0.19751400\n-0.09774327\n0.02083571\n\n\n3\n1.5390943\n-1.2248578\n-1.18974312\n-1.01640292\n1.24081519\n-1.56325995\n0.1443340\n1.1160357\n1.18990142\n0.87534532\n-0.70940648\n\n\n4\n-0.4547285\n1.0148821\n1.03501272\n0.23062775\n-1.26536265\n0.47549334\n-0.4973577\n-0.8680278\n-0.81414308\n-0.93181921\n-0.50303369",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_8.html#masalah-lainnya",
    "href": "pre_8.html#masalah-lainnya",
    "title": "8  PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI",
    "section": "8.3 Masalah Lainnya",
    "text": "8.3 Masalah Lainnya\nRegresi dan clustering menjadi dua contoh yang paling nyata tentang optimisasi pada machine learning.\n\nSupport Vector Machines (SVM)\n\nSVM bertujuan untuk menemukan hyperplane terbaik yang memisahkan beberapa kelas (kategori) dengan margin sebesar mungkin. Ini diubah menjadi masalah optimisasi cembung (convex optimization) di mana kita meminimalkan norma bobot (untuk memaksimalkan margin) dengan kendala bahwa setiap titik data diklasifikasikan dengan benar (atau hampir benar untuk soft-margin SVM).\n\nNeural Networks (Deep Learning)\n\nProses training neural network melibatkan optimisasi bobot dan bias untuk meminimalkan fungsi kerugian (loss function) seperti cross-entropy atau mean squared error. Ini biasanya dilakukan dengan gradient descent (misalnya: SGD dan Adam) yang merupakan algoritma optimisasi iteratif.\n\nPrincipal Component Analysis (PCA)\n\nPCA dapat diformulasikan sebagai masalah optimisasi di mana kita mencari arah (komponen utama) yang memaksimalkan varians data yang diproyeksikan. Ini equivalen dengan mencari eigenvectors dari matriks kovarians yang sesuai dengan eigenvalues terbesar.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>PERMASALAHAN YANG BISA DIPANDANG SEBAGAI OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_9.html",
    "href": "pre_9.html",
    "title": "9  SOAL OPTIMISASI",
    "section": "",
    "text": "9.1 Masalah Regresi Linear\nBerikut ini ada beberapa masalah optimisasi yang bisa dicoba selesaikan dengan ompr atau spiral dynamic.\nAmbil data longley dari base R sebagai berikut:\nlongley |&gt; \n  janitor::clean_names() |&gt; \n  gt() |&gt; \n  gt_theme_538() |&gt;\n  tab_header(title = \"Data Longley\",\n             subtitle = \"Diambil dari base R\")\n\n\n\n\n\n\n\nData Longley\n\n\nDiambil dari base R\n\n\ngnp_deflator\ngnp\nunemployed\narmed_forces\npopulation\nyear\nemployed\n\n\n\n\n83.0\n234.289\n235.6\n159.0\n107.608\n1947\n60.323\n\n\n88.5\n259.426\n232.5\n145.6\n108.632\n1948\n61.122\n\n\n88.2\n258.054\n368.2\n161.6\n109.773\n1949\n60.171\n\n\n89.5\n284.599\n335.1\n165.0\n110.929\n1950\n61.187\n\n\n96.2\n328.975\n209.9\n309.9\n112.075\n1951\n63.221\n\n\n98.1\n346.999\n193.2\n359.4\n113.270\n1952\n63.639\n\n\n99.0\n365.385\n187.0\n354.7\n115.094\n1953\n64.989\n\n\n100.0\n363.112\n357.8\n335.0\n116.219\n1954\n63.761\n\n\n101.2\n397.469\n290.4\n304.8\n117.388\n1955\n66.019\n\n\n104.6\n419.180\n282.2\n285.7\n118.734\n1956\n67.857\n\n\n108.4\n442.769\n293.6\n279.8\n120.445\n1957\n68.169\n\n\n110.8\n444.546\n468.1\n263.7\n121.950\n1958\n66.513\n\n\n112.6\n482.704\n381.3\n255.2\n123.366\n1959\n68.655\n\n\n114.2\n502.601\n393.1\n251.4\n125.368\n1960\n69.564\n\n\n115.7\n518.173\n480.6\n257.2\n127.852\n1961\n69.331\n\n\n116.9\n554.894\n400.7\n282.7\n130.081\n1962\n70.551\nKita akan membuat regresi linear sebagai berikut:\n\\[population \\simeq x_1employed + x_2\\]",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_9.html#masalah-regresi-non-linear",
    "href": "pre_9.html#masalah-regresi-non-linear",
    "title": "9  SOAL OPTIMISASI",
    "section": "9.2 Masalah Regresi Non Linear",
    "text": "9.2 Masalah Regresi Non Linear\nDari data longley yang digunakan pada masalah sebelumnya, buat regresi non linear sebagai berikut:\n\\[population \\simeq x_1 \\ employed + x_2 \\ \\sqrt{unemployed} + x_3 \\ armedforces^2 + x_4\\]",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_9.html#masalah-urutan",
    "href": "pre_9.html#masalah-urutan",
    "title": "9  SOAL OPTIMISASI",
    "section": "9.3 Masalah Urutan",
    "text": "9.3 Masalah Urutan\nSeorang pelatih estafet hendak mendaftarkan timnya untuk mengikuti kompetisi di suatu waktu. Pelatih tersebut harus memilih 4 dari 6 orang pelari anak didiknya. Untuk itu, dia melakukan beberapa kali simulasi dan mencatatkan waktunya sebagai berikut:\n\n\n\nPelari\nFraction 1\nFraction 2\nFraction 3\nFraction 4\n\n\n\n\nSprinter 1\n12.27\n11.57\n11.54\n12.07\n\n\nSprinter 2\n11.34\n11.45\n12.45\n12.34\n\n\nSprinter 3\n11.29\n11.50\n11.45\n11.52\n\n\nSprinter 4\n12.54\n12.34\n12.32\n11.57\n\n\nSprinter 5\n12.20\n11.22\n12.07\n12.03\n\n\nSprinter 6\n11.54\n11.48\n11.56\n12.30\n\n\n\nHanya boleh satu pelari yang menempati satu fraction.\nBagaimana cara si pelatih menentukan pelari mana yang harus di-assign?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_9.html#masalah-pengelompokkan-routing",
    "href": "pre_9.html#masalah-pengelompokkan-routing",
    "title": "9  SOAL OPTIMISASI",
    "section": "9.4 Masalah Pengelompokkan Routing",
    "text": "9.4 Masalah Pengelompokkan Routing\nMisalkan suatu perusahaan logistik harus mengantarkan paket kepada 50 titik alamat pengantaran. Lokasi awal pengantaran ada di titik (50,50).\nBerikut adalah datanya:\n\nrm(list=ls())\n\ndf = read.csv(\"data_toko.csv\")\n\ndf |&gt; \n  gt() |&gt; \n  gt_theme_538() |&gt;\n  tab_header(title = \"Data Titik Alamat\",\n             subtitle = \"50 Toko\")\n\n\n\n\n\n\n\nData Titik Alamat\n\n\n50 Toko\n\n\nx\ny\n\n\n\n\n91\n45\n\n\n99\n72\n\n\n68\n6\n\n\n51\n33\n\n\n71\n42\n\n\n14\n53\n\n\n93\n80\n\n\n92\n58\n\n\n43\n23\n\n\n67\n50\n\n\n36\n13\n\n\n80\n32\n\n\n69\n70\n\n\n39\n1\n\n\n31\n83\n\n\n64\n98\n\n\n25\n43\n\n\n81\n93\n\n\n34\n62\n\n\n8\n37\n\n\n18\n89\n\n\n73\n66\n\n\n66\n78\n\n\n2\n11\n\n\n33\n30\n\n\n11\n86\n\n\n82\n87\n\n\n44\n74\n\n\n89\n76\n\n\n24\n52\n\n\n50\n75\n\n\n83\n51\n\n\n30\n71\n\n\n52\n18\n\n\n32\n28\n\n\n76\n7\n\n\n40\n27\n\n\n16\n2\n\n\n45\n4\n\n\n58\n17\n\n\n53\n5\n\n\n60\n95\n\n\n63\n38\n\n\n28\n97\n\n\n47\n12\n\n\n78\n64\n\n\n22\n55\n\n\n17\n59\n\n\n13\n35\n\n\n29\n96\n\n\n\n\n\n\n\nData bisa di-download di sini1.\nMisalkan dalam sekali pengantaran paket, kurir mampu membawa 10-15 paket, kelompokkan 50 titik tersebut menjadi seminimal mungkin kelompok dengan jarak rute terkecil!",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_9.html#footnotes",
    "href": "pre_9.html#footnotes",
    "title": "9  SOAL OPTIMISASI",
    "section": "",
    "text": "https://github.com/Nutrifood-Data-Science/LearningForum/blob/main/10%20Optimisasi/OptimBook/data_toko.csv↩︎",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_10.html",
    "href": "pre_10.html",
    "title": "10  JAWABAN SOAL OPTIMISASI",
    "section": "",
    "text": "10.1 Masalah Regresi Linear\nPada bagian ini, kita akan jawab soal pada part sebelumnya dengan beberapa cara:\nData:\ndf = longley |&gt; janitor::clean_names() |&gt; select(employed,population)\ndf\n\n     employed population\n1947   60.323    107.608\n1948   61.122    108.632\n1949   60.171    109.773\n1950   61.187    110.929\n1951   63.221    112.075\n1952   63.639    113.270\n1953   64.989    115.094\n1954   63.761    116.219\n1955   66.019    117.388\n1956   67.857    118.734\n1957   68.169    120.445\n1958   66.513    121.950\n1959   68.655    123.366\n1960   69.564    125.368\n1961   69.331    127.852\n1962   70.551    130.081\nDefinisikan fungsi matriks rotasi:\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n\n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  \n  return(mat_rot)\n}\nDefinisikan beberapa fungsi lain:\n# generate calon solusi\ngenerate_calon = function(){runif(2,min = -100,max = 100)}\n\n# fungsi objektif\n# input = generate_calon()\nobj_func = function(input){\n  pred = \n    df |&gt; \n    # hitung value prediksi\n    mutate(pred = input[1] * employed + input[2]) |&gt; \n    pull(pred)\n  # perhitungan mae\n  Metrics::mae(df$population,pred)\n}\nTargetnya adalah meminimumkan mean absolute error sebagai fungsi objektifnya. Kita mulai algoritmanya:\nN_spiral = ncore * 15\niter_max = 60\ndimensi  = 2\n\n# bikin matriks rotasinya\nA_rot = buat_rot_mat(2*pi/30,dimensi)\n\n# kita generate calon solusi\nid_calon = 1:N_spiral\ncalon    = vector(\"list\",N_spiral)\nfor(i in 1:N_spiral){\n  calon[[i]] = generate_calon()\n  }\n\n# iterasi pertama\nf_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\n# iterasi kedua dan seterusnya hingga iter_max\nfor(ix in 1:iter_max){\n  # penentuan calon paling minimum\n  id_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n  # ambil komponen terkecil pertama saja\n  id_min = id_min[1]\n  pusat  = calon[[id_min]]\n  \n  # kelak akan ada loop tapi pusat gravitasi tak diikutsertakan\n  loop = 1:N_spiral\n  loop = loop[-id_min]\n  \n  # proses rotasi semua calon\n  for(i in loop){\n    Xt = calon[[i]]\n    X  = A_rot %*% (Xt - pusat)\n    X  = pusat + (.9 * X)\n    calon[[i]] = X\n    }\n  f_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n}\n\n# penentuan solusi final\nid_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n# ambil komponen terkecil pertama saja\nid_min = id_min[1]\nsolusi = calon[[id_min]]\nBerikut adalah solusi yang dihasilkan:\n# solusinya\ndata.frame(ket   = c(\"x_1\",\"x_2\"),\n           value = solusi) |&gt; knitr::kable()\n\n\n\n\nket\nvalue\n\n\n\n\nx_1\n1.910025\n\n\nx_2\n-7.725589\nMean absolute error yang dihasilkan:\n# MAE\nmin(f_hit)\n\n[1] 1.569485\nBerikut adalah perbandingan dengan base R:\nmodel = lm(population~employed,df)\npred  = predict(model,df)\nMean absolute error yang dihasilkan:\nMetrics::mae(df$population,pred)\n\n[1] 1.624758\nBerikut adalah koefisien regresinya:\nmodel\n\n\nCall:\nlm(formula = population ~ employed, data = df)\n\nCoefficients:\n(Intercept)     employed  \n     -6.824        1.902",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>JAWABAN SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_10.html#masalah-regresi-non-linear",
    "href": "pre_10.html#masalah-regresi-non-linear",
    "title": "10  JAWABAN SOAL OPTIMISASI",
    "section": "10.2 Masalah Regresi Non Linear",
    "text": "10.2 Masalah Regresi Non Linear\nData:\n\ndf = longley |&gt; janitor::clean_names() |&gt; select(population,employed,unemployed,armed_forces)\ndf\n\n     population employed unemployed armed_forces\n1947    107.608   60.323      235.6        159.0\n1948    108.632   61.122      232.5        145.6\n1949    109.773   60.171      368.2        161.6\n1950    110.929   61.187      335.1        165.0\n1951    112.075   63.221      209.9        309.9\n1952    113.270   63.639      193.2        359.4\n1953    115.094   64.989      187.0        354.7\n1954    116.219   63.761      357.8        335.0\n1955    117.388   66.019      290.4        304.8\n1956    118.734   67.857      282.2        285.7\n1957    120.445   68.169      293.6        279.8\n1958    121.950   66.513      468.1        263.7\n1959    123.366   68.655      381.3        255.2\n1960    125.368   69.564      393.1        251.4\n1961    127.852   69.331      480.6        257.2\n1962    130.081   70.551      400.7        282.7\n\n\nDefinisikan fungsi matriks rotasi:\n\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n\n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  \n  return(mat_rot)\n}\n\nDefinisikan beberapa fungsi lain:\n\n# generate calon solusi\ngenerate_calon = function(){runif(4,min = -400,max = 400)}\n\n# fungsi objektif\n# input = generate_calon()\nobj_func = function(input){\n  pred = \n    df |&gt; \n    # hitung value prediksi\n    mutate(pred = input[1] * employed + \n                  input[2] * sqrt(unemployed) + \n                  input[3] * armed_forces^2 + \n                  input[4]) |&gt; \n    pull(pred)\n  # perhitungan mae\n  Metrics::mae(df$population,pred)\n}\n\nTargetnya adalah meminimumkan mean absolute error sebagai fungsi objektifnya. Kita mulai algoritmanya:\n\nN_spiral = ncore * 100\niter_max = 40\ndimensi  = 4\n\n# bikin matriks rotasinya\nA_rot = buat_rot_mat(2*pi/30,dimensi)\n\n# kita generate calon solusi\nid_calon = 1:N_spiral\ncalon    = vector(\"list\",N_spiral)\nfor(i in 1:N_spiral){\n  calon[[i]] = generate_calon()\n  }\n\n# iterasi pertama\nf_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\n# iterasi kedua dan seterusnya hingga iter_max\nfor(ix in 1:iter_max){\n  # penentuan calon paling minimum\n  id_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n  # ambil komponen terkecil pertama saja\n  id_min = id_min[1]\n  pusat  = calon[[id_min]]\n  \n  # kelak akan ada loop tapi pusat gravitasi tak diikutsertakan\n  loop = 1:N_spiral\n  loop = loop[-id_min]\n  \n  # proses rotasi semua calon\n  for(i in loop){\n    Xt = calon[[i]]\n    X  = A_rot %*% (Xt - pusat)\n    X  = pusat + (.8 * X)\n    calon[[i]] = X\n    }\n  f_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n}\n\n# penentuan solusi final\nid_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n# ambil komponen terkecil pertama saja\nid_min = id_min[1]\nsolusi = calon[[id_min]]\n\nBerikut adalah solusi yang dihasilkan:\n\n# solusinya\ndata.frame(ket   = c(\"x_1\",\"x_2\",\"x_3\",\"x_4\"),\n           value = solusi) |&gt; knitr::kable()\n\n\n\n\nket\nvalue\n\n\n\n\nx_1\n48.1017326\n\n\nx_2\n-138.2382038\n\n\nx_3\n-0.0081152\n\n\nx_4\n28.8421670\n\n\n\n\n\nMean absolute error yang dihasilkan:\n\n# MAE\nmin(f_hit)\n\n[1] 213.5873",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>JAWABAN SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_10.html#masalah-urutan-pelari",
    "href": "pre_10.html#masalah-urutan-pelari",
    "title": "10  JAWABAN SOAL OPTIMISASI",
    "section": "10.3 Masalah Urutan Pelari",
    "text": "10.3 Masalah Urutan Pelari\nKita punya data waktu pelari per fraction:\n\ndf =data.frame(runner = c(1:6),\n               f1     = c(12.27,11.34,11.29,12.54,12.20,11.54),\n               f2     = c(11.57,11.45,11.50,12.34,11.22,11.48),\n               f3     = c(11.54,12.45,11.45,12.32,12.07,11.56),\n               f4     = c(12.07,12.34,11.52,11.57,12.03,12.30)\n               ) \ndf |&gt; \n  gt() %&gt;% \n  gt_theme_538() %&gt;% \n  tab_header(title = \"Waktu Pelari di Setiap Fraction\",\n             subtitle = \"Data Input\")\n\n\n\n\n\n\n\nWaktu Pelari di Setiap Fraction\n\n\nData Input\n\n\nrunner\nf1\nf2\nf3\nf4\n\n\n\n\n1\n12.27\n11.57\n11.54\n12.07\n\n\n2\n11.34\n11.45\n12.45\n12.34\n\n\n3\n11.29\n11.50\n11.45\n11.52\n\n\n4\n12.54\n12.34\n12.32\n11.57\n\n\n5\n12.20\n11.22\n12.07\n12.03\n\n\n6\n11.54\n11.48\n11.56\n12.30\n\n\n\n\n\n\n\nDefinisikan fungsi matriks rotasi:\n\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n\n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  \n  return(mat_rot)\n}\n\nDefinisikan beberapa fungsi lain:\n\n# generate solusi\ngenerate_calon = function(){runif(6)}\n\n# objective function\nobj_func = function(calon){\n  # kita sort dulu\n  urut = calon |&gt; sort()\n  # ambil hanya 4\n  urut = urut[1:4]\n  \n  # dimana letak urutannya\n  urutan_1 = which(calon == urut[1])\n  urutan_2 = which(calon == urut[2])\n  urutan_3 = which(calon == urut[3])\n  urutan_4 = which(calon == urut[4])\n  \n  # jumlahkan waktunya\n  output = sum(df$f1[urutan_1],df$f2[urutan_2],df$f3[urutan_3],df$f4[urutan_4])\n  return(output)\n}\n\nTargetnya adalah meminimumkan waktu total lari sebagai fungsi objektifnya. Kita mulai algoritmanya:\n\nN_spiral = ncore * 2\niter_max = 10\ndimensi  = 6\n\n# bikin matriks rotasinya\nA_rot = buat_rot_mat(2*pi/30,dimensi)\n\n# kita generate calon solusi\nid_calon = 1:N_spiral\ncalon    = vector(\"list\",N_spiral)\nfor(i in 1:N_spiral){\n  calon[[i]] = generate_calon()\n  }\n\n# iterasi pertama\nf_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\n# iterasi kedua dan seterusnya hingga iter_max\nfor(ix in 1:iter_max){\n  # penentuan calon paling minimum\n  id_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n  # ambil komponen terkecil pertama saja\n  id_min = id_min[1]\n  pusat  = calon[[id_min]]\n  \n  # kelak akan ada loop tapi pusat gravitasi tak diikutsertakan\n  loop = 1:N_spiral\n  loop = loop[-id_min]\n  \n  # proses rotasi semua calon\n  for(i in loop){\n    Xt = calon[[i]]\n    X  = A_rot %*% (Xt - pusat)\n    X  = pusat + (.9 * X)\n    calon[[i]] = X\n    }\n  f_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n}\n\n# penentuan solusi final\nid_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n# ambil komponen terkecil pertama saja\nid_min = id_min[1]\nsolusi = calon[[id_min]]\n\nBerikut adalah solusi yang dihasilkan:\n\n# kita sort dulu\nurut = solusi |&gt; sort()\n# ambil hanya 4\nurut = urut[1:4]\n  \n# dimana letak urutannya\nurutan_1 = which(solusi == urut[1])\nurutan_2 = which(solusi == urut[2])\nurutan_3 = which(solusi == urut[3])\nurutan_4 = which(solusi == urut[4])\n\nUrutan pelari: 2 -&gt; 5 -&gt; 3 -&gt; 4.\nDengan total waktu yang didapatkan sebesar:\n\nf_hit[id_min]\n\n[1] 45.58",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>JAWABAN SOAL OPTIMISASI</span>"
    ]
  },
  {
    "objectID": "pre_10.html#masalah-pengelompokkan-routing",
    "href": "pre_10.html#masalah-pengelompokkan-routing",
    "title": "10  JAWABAN SOAL OPTIMISASI",
    "section": "10.4 Masalah Pengelompokkan Routing",
    "text": "10.4 Masalah Pengelompokkan Routing\nKita punya data lokasi toko:\n\ndf = read.csv(\"data_toko.csv\") |&gt; arrange(x,y)\ndf |&gt; \n  gt() %&gt;% \n  gt_theme_538() %&gt;% \n  tab_header(title = \"Data Lokasi Toko\",\n             subtitle = \"Data Input\")\n\n\n\n\n\n\n\nData Lokasi Toko\n\n\nData Input\n\n\nx\ny\n\n\n\n\n2\n11\n\n\n8\n37\n\n\n11\n86\n\n\n13\n35\n\n\n14\n53\n\n\n16\n2\n\n\n17\n59\n\n\n18\n89\n\n\n22\n55\n\n\n24\n52\n\n\n25\n43\n\n\n28\n97\n\n\n29\n96\n\n\n30\n71\n\n\n31\n83\n\n\n32\n28\n\n\n33\n30\n\n\n34\n62\n\n\n36\n13\n\n\n39\n1\n\n\n40\n27\n\n\n43\n23\n\n\n44\n74\n\n\n45\n4\n\n\n47\n12\n\n\n50\n75\n\n\n51\n33\n\n\n52\n18\n\n\n53\n5\n\n\n58\n17\n\n\n60\n95\n\n\n63\n38\n\n\n64\n98\n\n\n66\n78\n\n\n67\n50\n\n\n68\n6\n\n\n69\n70\n\n\n71\n42\n\n\n73\n66\n\n\n76\n7\n\n\n78\n64\n\n\n80\n32\n\n\n81\n93\n\n\n82\n87\n\n\n83\n51\n\n\n89\n76\n\n\n91\n45\n\n\n92\n58\n\n\n93\n80\n\n\n99\n72\n\n\n\n\n\n\n\ndan lokasi kantor di (50,50).\nDefinisikan fungsi matriks rotasi:\n\nbuat_rot_mat = function(theta,n){\n  # buat template sebuah matriks identitas\n  temp_mat = matrix(0,ncol = n,nrow = n)\n  diag(temp_mat) = 1\n  \n  # buat matriks identitas terlebih dahulu\n  mat_rot = temp_mat\n\n  for(i in 1:(n-1)){\n    for(j in 1:i){\n      temp = temp_mat\n      idx = n-i\n      idy = n+1-j\n      # print(paste0(\"Matriks rotasi untuk \",idx,\" - \",idy,\": DONE\"))\n      temp[idx,idx] = cos(theta)\n      temp[idx,idy] = -sin(theta)\n      temp[idy,idx] = sin(theta)\n      temp[idy,idy] = cos(theta)\n      # assign(paste0(\"M\",idx,idy),temp)\n      mat_rot = mat_rot %*% temp\n      mat_rot = mat_rot \n    }\n  }\n  \n  return(mat_rot)\n}\n\nDefinisikan beberapa fungsi lain:\n\n# generate solusi\ngenerate_calon = function(){\n  randomin = sample(4,1)\n  if(randomin == 1){output = sample(4,50,replace = T)}\n  if(randomin == 2){output = sample(5,50,replace = T)}\n  if(randomin == 3){output = sample(4,50,replace = T) |&gt; sort()}\n  if(randomin == 4){output = sample(5,50,replace = T) |&gt; sort()}\n  return(output)\n  }\n\n# info lokasi kantor\nlokasi_kantor = data.frame(x = 50,y = 50)\n\n# fungsi yang menambah lokasi kantor ke data frame per rute\n# lalu mengubahkan menjadi matriks jarak\n# kemudian dengan TSP mengubahnya menjadi jarak\nhitung_jarak = function(input){\n  mat_jar = \n    input |&gt; \n    select(-rute) |&gt; \n    # menambahkan lokasi kantor\n    rbind(lokasi_kantor) |&gt;\n    # mengubah menjadi matriks jarak\n    dist()\n\n  # mengubah matriks jarak menjadi TSP\n  obj = TSP::as.TSP(mat_jar)\n  tur = TSP::solve_TSP(obj)\n  # solving TSP\n  jar = TSP::tour_length(tur)\n\n  return(jar)\n}\n\n# objective function\nobj_func = function(calon){\n  calon = floor(calon)\n  # memasukkan calon rute\n  df_split = \n    df |&gt; \n    mutate(rute = calon) |&gt; \n    group_split(rute)\n\n  # hitung total jarak\n  total_jarak = sapply(df_split,hitung_jarak) |&gt; sum()\n  \n  # kasih penalti untuk rute yang isinya kurang dari 10 atau lebih dari 15\n  tes   = table(calon)\n  pen_1 = sum(tes &lt; 10) * 100\n  pen_2 = sum(tes &gt; 15) * 100\n  \n  # rute hanya boleh ada 4 atau 5 saja\n  n_rute = calon |&gt; unique() |&gt; length()\n  pen_ru = ifelse(n_rute &lt; 4 | n_rute &gt; 5,1000,0)\n  \n  # kita jumlahkan semua\n  output = total_jarak + pen_1 + pen_2 + pen_ru\n  return(output)\n}\n\nTargetnya adalah meminimumkan total jarak serta penalti dari berapa banyak anggota rute sebagai fungsi objektifnya. Kita mulai algoritmanya:\n\nN_spiral = ncore * 30\niter_max = 20\ndimensi  = 50\n\n# bikin matriks rotasinya\nA_rot = buat_rot_mat(2*pi/6,dimensi)\n\n# kita generate calon solusi\nid_calon = 1:N_spiral\ncalon    = vector(\"list\",N_spiral)\nfor(i in 1:N_spiral){\n  calon[[i]] = generate_calon()\n  }\n\n# iterasi pertama\nf_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n\n# iterasi kedua dan seterusnya hingga iter_max\nfor(ix in 1:iter_max){\n  # penentuan calon paling minimum\n  id_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n  # ambil komponen terkecil pertama saja\n  id_min = id_min[1]\n  pusat  = calon[[id_min]]\n  \n  # kelak akan ada loop tapi pusat gravitasi tak diikutsertakan\n  loop = 1:N_spiral\n  loop = loop[-id_min]\n  \n  # proses rotasi semua calon\n  for(i in loop){\n    Xt = calon[[i]]\n    X  = A_rot %*% (Xt - pusat)\n    X  = pusat + (.8 * X)\n    X  = ifelse(X &lt; 1,max(X),X)\n    X  = ifelse(X &gt; 5,1,X)\n    # X  = floor(X)\n    calon[[i]] = X\n    }\n  f_hit = mcmapply(obj_func,calon,mc.cores = ncore)\n}\n\n# penentuan solusi final\nid_min = id_calon[which(f_hit == min(f_hit))] %&gt;% min()\n# ambil komponen terkecil pertama saja\nid_min = id_min[1]\nsolusi = calon[[id_min]] |&gt; floor()\n\nBerikut adalah solusi yang dihasilkan:\n\n# solusi\ntable(solusi)\n\nsolusi\n 1  2  3  4 \n15 13 12 10 \n\nlibrary(ggplot2)\n# Plot scatterplot dengan warna berdasarkan z dan garis penghubung\ndf |&gt; \n  mutate(z = solusi) |&gt; \n  ggplot(aes(x = x, y = y, color = factor(z), group = z)) +\n  geom_point(size = 3) +  # Titik scatterplot\n  geom_line(alpha = 0.7) +  # Garis penghubung dalam kategori yang sama\n  labs(\n    title = \"Pengelompokan Routing\",\n    x = \"x\",\n    y = \"y\",\n    color = \"Kelompok Routing\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    plot.title = element_text(hjust = 0.5, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\nDengan nilai total jarak yang didapatkan sebesar:\n\nf_hit[id_min]\n\n[1] 853.7679",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>JAWABAN SOAL OPTIMISASI</span>"
    ]
  }
]