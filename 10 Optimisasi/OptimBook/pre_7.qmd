# `or tools` GOOGLE __*PYTHON*__

__OR-Tools__ (___Operations Research Tools___) adalah _library_ _open-source_ buatan Google yang dikembangkan untuk menyelesaikan masalah optimasi kombinatorial dan pemrograman matematika. Diluncurkan sekitar tahun 2010, _library_ ini dirancang untuk menjadi alat yang _scalable_ dan efisien dalam menyelesaikan masalah kompleks seperti _routing_ kendaraan, penjadwalan, penugasan, dan optimasi linear. __OR-Tools__ dibangun berdasarkan pengalaman internal Google dalam menangani masalah optimasi skala besar dan menggabungkan berbagai _state-of-the-art solver_ serta algoritma heuristik.

Yang membuat __OR-Tools__ istimewa adalah dukungannya terhadap _multiple programming_ _languages_ (C++, Python, Java, C#), fleksibilitas dalam pemodelan masalah, dan kemampuan untuk menangani berbagai tipe masalah optimasi seperti _linear programming_, _constraint programming_, dan _mixed-integer programming_. _Library_ ini tidak hanya menyediakan _solver_ internal yang powerful tetapi juga dapat terintegrasi dengan _solver_ eksternal seperti `SCIP`, `GLPK`, dan `CP-SAT`, menjadikannya pilihan populer baik untuk penelitian akademis maupun aplikasi industri skala enterprise.

Jangan lupa untuk menginstall `ortools` di `terminal`:

```
pip install ortools
```

## Penyelesaian Masalah __*Knapsack Problem*__

Berikut adalah skrip di __Python__ nya:

```
from ortools.linear_solver import pywraplp

def solve_milp():
    # Membuat solver
    solver = pywraplp.Solver.CreateSolver('SCIP')
    
    # Membuat variabel
    x = {}
    y = {}
    for i in range(1, 3):
        x[i] = solver.IntVar(0, solver.infinity(), f'x_{i}')
        y[i] = solver.BoolVar(f'y_{i}')
    
    # Membuat objective function
    objective = solver.Objective()
    objective.SetCoefficient(x[1], 400000)
    objective.SetCoefficient(x[2], 250000)
    objective.SetCoefficient(y[1], -500000)
    objective.SetCoefficient(y[2], -300000)
    objective.SetMaximization()
    
    # Menambah constraints
    # Constraint 1: 4*x1 + 2*x2 <= 100
    constraint1 = solver.Constraint(-solver.infinity(), 100)
    constraint1.SetCoefficient(x[1], 4)
    constraint1.SetCoefficient(x[2], 2)
    
    # Constraint 2: 2*x1 + 3*x2 <= 90
    constraint2 = solver.Constraint(-solver.infinity(), 90)
    constraint2.SetCoefficient(x[1], 2)
    constraint2.SetCoefficient(x[2], 3)
    
    # Constraint 3: 5*x1 + 3*x2 <= 120
    constraint3 = solver.Constraint(-solver.infinity(), 120)
    constraint3.SetCoefficient(x[1], 5)
    constraint3.SetCoefficient(x[2], 3)
    
    # Constraint 4: x1 <= 1000*y1
    constraint4 = solver.Constraint(-solver.infinity(), 0)
    constraint4.SetCoefficient(x[1], 1)
    constraint4.SetCoefficient(y[1], -1000)
    
    # Constraint 5: x2 <= 1000*y2
    constraint5 = solver.Constraint(-solver.infinity(), 0)
    constraint5.SetCoefficient(x[2], 1)
    constraint5.SetCoefficient(y[2], -1000)
    
    # Solve the problem
    status = solver.Solve()
    
    # Print results
    if status == pywraplp.Solver.OPTIMAL:
        print('Solution:')
        print('Objective value =', solver.Objective().Value())
        for i in range(1, 3):
            print(f'x[{i}] =', x[i].solution_value())
        for i in range(1, 3):
            print(f'y[{i}] =', int(y[i].solution_value()))
    else:
        print('The problem does not have an optimal solution.')

# Run the solver
solve_milp()
```

Kita dapatkan hasil yang sama, yakni:

```
Solution:
Objective value = 9100000.000000002
x[1] = 24.0
x[2] = 0.0
y[1] = 1
y[2] = 0
```