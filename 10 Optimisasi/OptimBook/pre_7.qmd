# `or tools` GOOGLE __*PYTHON*__

__OR-Tools__ (___Operations Research Tools___) adalah _library_ _open-source_ buatan Google yang dikembangkan untuk menyelesaikan masalah optimasi kombinatorial dan pemrograman matematika. Diluncurkan sekitar tahun 2010, _library_ ini dirancang untuk menjadi alat yang _scalable_ dan efisien dalam menyelesaikan masalah kompleks seperti _routing_ kendaraan, penjadwalan, penugasan, dan optimasi linear. __OR-Tools__ dibangun berdasarkan pengalaman internal Google dalam menangani masalah optimasi skala besar dan menggabungkan berbagai _state-of-the-art solver_ serta algoritma heuristik.

Yang membuat __OR-Tools__ istimewa adalah dukungannya terhadap _multiple programming_ _languages_ (C++, Python, Java, C#), fleksibilitas dalam pemodelan masalah, dan kemampuan untuk menangani berbagai tipe masalah optimasi seperti _linear programming_, _constraint programming_, dan _mixed-integer programming_. _Library_ ini tidak hanya menyediakan _solver_ internal yang powerful tetapi juga dapat terintegrasi dengan _solver_ eksternal seperti `SCIP`, `GLPK`, dan `CP-SAT`, menjadikannya pilihan populer baik untuk penelitian akademis maupun aplikasi industri skala enterprise.

## Filosofi Inti: _"Define, Solve, Print"_

OR-Tools menganut filosofi yang sangat 
jelas dan elegan:

1.  **Define**: Anda mendefinisikan 
*model* permasalahan optimisasi Anda. 
Ini melibatkan:
    *   **Variabel Keputusan**: Hal-hal 
yang nilainya ingin Anda cari (misal: 
apakah truk A pergi ke kota X? Kapan 
mesin B mulai memproduksi barang C?).
    *   **Constraints (Kendala)**: 
Batasan-batasan yang harus dipatuhi 
(misal: sebuah truk tidak dapat membawa 
melebihi kapasitasnya, sebuah tugas 
harus selesai sebelum tugas lainnya 
dimulai).
    *   **Objective Function (Fungsi 
Tujuan)**: Tujuan yang ingin 
dimaksimalkan atau diminimalkan (misal: 
minimalkan total jarak tempuh, 
maksimalkan utilisasi mesin, minimalkan 
total keterlambatan).

2.  **Solve**: Anda memilih *solver* 
yang tepat (CP-SAT, Linear Solver, dll.)
dan meminta OR-Tools untuk mencari 
solusi terbaik yang memenuhi semua 
kendala.

3.  **Print**: Anda mengekstrak dan 
menampilkan atau menggunakan solusi yang
ditemukan.

## Komponen-Komponen Utama dan Jenis Masalah yang Ditangani

OR-Tools bukanlah satu *solver* tunggal,
melainkan kumpulan beberapa *solver* 
yang masing-masing ahli di bidangnya:

1.  **Constraint Programming (CP-SAT 
Solver)**
    *   **Apa itu?** Sebuah *solver* 
yang dirancang untuk masalah dengan 
banyak kendala logis yang kompleks dan 
variabel yang harus mengambil nilai dari
himpunan yang terbatas (diskrit).
    *   **Kekuatan:** Sangat hebat dalam
menangani kendala "jika-maka", 
"alldifferent", dan logika non-linear.
    *   **Contoh Masalah:**
        *   Penjadwalan: Penjadwalan 
shift karyawan, penjadwalan produksi di 
pabrik.
        *   Perutean Kendaraan (*Vehicle
Routing*).
        *   Penempatan (*Assignment*): 
Menugaskan tugas ke mesin atau pekerja.
        *   Puzzles: Seperti Sudoku, 
N-Queens.

2.  **Linear and Mixed-Integer 
Programming (MIP Solver)**
    *   **Apa itu?** *Solver* untuk 
masalah dimana Fungsi Tujuan dan semua 
Kendala adalah *linear*. Jika beberapa 
variabel harus bilangan integer 
(bilangan bulat), disebut *Mixed-Integer
Programming* (MIP).
    *   **Kekuatan:** Efisien untuk 
masalah optimisasi dengan struktur 
matematis linear yang jelas, sering 
digunakan dalam alokasi sumber daya dan 
perencanaan.
    *   **Contoh Masalah:**
        *   Masalah Knapsack: Memilih 
kombinasi barang dengan nilai tertinggi 
tanpa melebihi kapasitas.
        *   Alokasi Anggaran.
        *   *Blending Problems*: 
Mencampur bahan baku dengan biaya 
terendah untuk memenuhi spesifikasi.
        *   *Cutting Stock*: Memotong 
material besar (kayu, kertas) dengan 
waste seminimal mungkin.

3.  **Vehicle Routing Library (VRP)**
    *   **Apa itu?** Sebuah *library* 
khusus yang dibangun di atas CP-SAT dan 
MIP solver untuk menyelesaikan berbagai 
varian masalah *Vehicle Routing Problem*
(VRP).
    *   **Fitur Unggulan:** Sudah 
memiliki built-in support untuk kendala 
seperti kapasitas kendaraan, waktu 
layanan, time windows (jendela waktu 
dimana lokasi harus dikunjungi), durasi 
perjalanan maksimal, dan banyak lagi. 
Ini sangat menghemat waktu karena kita 
tidak perlu mendefinisikan semua kendala
ini dari nol.
    *   **Contoh Masalah:** Logistik dan
distribusi, layanan kurir, pengumpulan 
sampah.

4.  **Graph Algorithms**
    *   **Apa itu?** Kumpulan algoritma 
klasik untuk menyelesaikan masalah pada 
graf (jaringan).
    *   **Contoh Algoritma:**
        *   *Shortest Path* (Dijkstra, 
A*): Mencari rute terpendek.
        *   *Minimal Cost Flow*: 
Mengalirkan barang dalam jaringan dengan
biaya minimal.
        *   *Max Flow*: Mencari 
kapasitas maksimal aliran dalam 
jaringan.

## Keunggulan OR-Tools

1.  **Berbasis Bahasa, Bukan GUI:** 
Berbeda dengan banyak software 
optimisasi komersial yang berbasis GUI 
(seperti Excel Solver), OR-Tools adalah 
sebuah *library* pemrograman. Ini 
memberikan fleksibilitas yang sangat 
tinggi. Anda dapat dengan mudah 
mengintegrasikannya ke dalam *pipeline* 
data, aplikasi web, atau sistem yang 
sudah ada.
2.  **Multi-Bahasa:** Dukungan untuk 
Python, C++, Java, dan C# membuatnya 
dapat diadopsi oleh hampir semua tim 
pengembangan.
3.  **Open Source dan Gratis:** Dapat 
digunakan untuk proyek komersial 
sekalipun tanpa biaya lisensi, dengan 
dukungan komunitas yang besar.
4.  **Powerful dan Terbukti:** 
Dikembangkan dan digunakan secara 
internal oleh Google untuk memecahkan 
masalah dunia nyata mereka (misal, 
penugasan iklan, perutean kendaraan, 
penjadwalan). Ini adalah jaminan 
kualitas yang sangat kuat.
5.  **Portabel:** Dapat dijalankan di 
Windows, macOS, Linux, dan bahkan di 
lingkungan cloud.
6.  **Tidak Bergantung pada Solver 
Eksternal (Opsional):** OR-Tools datang 
dengan solver-nya sendiri yang sudah 
sangat capable (CP-SAT, GLOP). Namun, ia
juga menyediakan antarmuka untuk solver 
komersial high-end seperti **Gurobi**, 
**CPLEX**, dan **SCIP** jika Anda 
membutuhkan kinerja ekstrem untuk 
masalah yang sangat besar dan sulit.

## Instalasi `or tools`

Jangan lupa untuk menginstall `ortools` di `terminal`:

```
pip install ortools
```

## Penyelesaian Masalah __*Knapsack Problem*__

Berikut adalah skrip di __Python__ nya:

```
from ortools.linear_solver import pywraplp

def solve_milp():
    # Membuat solver
    solver = pywraplp.Solver.CreateSolver('SCIP')
    
    # Membuat variabel
    x = {}
    y = {}
    for i in range(1, 3):
        x[i] = solver.IntVar(0, solver.infinity(), f'x_{i}')
        y[i] = solver.BoolVar(f'y_{i}')
    
    # Membuat objective function
    objective = solver.Objective()
    objective.SetCoefficient(x[1], 400000)
    objective.SetCoefficient(x[2], 250000)
    objective.SetCoefficient(y[1], -500000)
    objective.SetCoefficient(y[2], -300000)
    objective.SetMaximization()
    
    # Menambah constraints
    # Constraint 1: 4*x1 + 2*x2 <= 100
    constraint1 = solver.Constraint(-solver.infinity(), 100)
    constraint1.SetCoefficient(x[1], 4)
    constraint1.SetCoefficient(x[2], 2)
    
    # Constraint 2: 2*x1 + 3*x2 <= 90
    constraint2 = solver.Constraint(-solver.infinity(), 90)
    constraint2.SetCoefficient(x[1], 2)
    constraint2.SetCoefficient(x[2], 3)
    
    # Constraint 3: 5*x1 + 3*x2 <= 120
    constraint3 = solver.Constraint(-solver.infinity(), 120)
    constraint3.SetCoefficient(x[1], 5)
    constraint3.SetCoefficient(x[2], 3)
    
    # Constraint 4: x1 <= 1000*y1
    constraint4 = solver.Constraint(-solver.infinity(), 0)
    constraint4.SetCoefficient(x[1], 1)
    constraint4.SetCoefficient(y[1], -1000)
    
    # Constraint 5: x2 <= 1000*y2
    constraint5 = solver.Constraint(-solver.infinity(), 0)
    constraint5.SetCoefficient(x[2], 1)
    constraint5.SetCoefficient(y[2], -1000)
    
    # Solve the problem
    status = solver.Solve()
    
    # Print results
    if status == pywraplp.Solver.OPTIMAL:
        print('Solution:')
        print('Objective value =', solver.Objective().Value())
        for i in range(1, 3):
            print(f'x[{i}] =', x[i].solution_value())
        for i in range(1, 3):
            print(f'y[{i}] =', int(y[i].solution_value()))
    else:
        print('The problem does not have an optimal solution.')

# Run the solver
solve_milp()
```

Kita dapatkan hasil yang sama, yakni:

```
Solution:
Objective value = 9100000.000000002
x[1] = 24.0
x[2] = 0.0
y[1] = 1
y[2] = 0
```